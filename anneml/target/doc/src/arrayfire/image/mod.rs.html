<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `&#x2F;home&#x2F;user&#x2F;.cargo&#x2F;registry&#x2F;src&#x2F;github.com-1ecc6299db9ec823&#x2F;arrayfire-3.8.0&#x2F;src&#x2F;image&#x2F;mod.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>mod.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="shortcut icon" href="http:&#x2F;&#x2F;www.rust-lang.org&#x2F;favicon.ico"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a class="sidebar-logo" href="../../../arrayfire/index.html"><div class="logo-container"><img src="http:&#x2F;&#x2F;www.arrayfire.com&#x2F;logos&#x2F;arrayfire_logo_symbol.png" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../arrayfire/index.html"><img src="http:&#x2F;&#x2F;www.arrayfire.com&#x2F;logos&#x2F;arrayfire_logo_symbol.png" alt="logo"></a><nav class="sub"><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">   1</span>
<span id="2">   2</span>
<span id="3">   3</span>
<span id="4">   4</span>
<span id="5">   5</span>
<span id="6">   6</span>
<span id="7">   7</span>
<span id="8">   8</span>
<span id="9">   9</span>
<span id="10">  10</span>
<span id="11">  11</span>
<span id="12">  12</span>
<span id="13">  13</span>
<span id="14">  14</span>
<span id="15">  15</span>
<span id="16">  16</span>
<span id="17">  17</span>
<span id="18">  18</span>
<span id="19">  19</span>
<span id="20">  20</span>
<span id="21">  21</span>
<span id="22">  22</span>
<span id="23">  23</span>
<span id="24">  24</span>
<span id="25">  25</span>
<span id="26">  26</span>
<span id="27">  27</span>
<span id="28">  28</span>
<span id="29">  29</span>
<span id="30">  30</span>
<span id="31">  31</span>
<span id="32">  32</span>
<span id="33">  33</span>
<span id="34">  34</span>
<span id="35">  35</span>
<span id="36">  36</span>
<span id="37">  37</span>
<span id="38">  38</span>
<span id="39">  39</span>
<span id="40">  40</span>
<span id="41">  41</span>
<span id="42">  42</span>
<span id="43">  43</span>
<span id="44">  44</span>
<span id="45">  45</span>
<span id="46">  46</span>
<span id="47">  47</span>
<span id="48">  48</span>
<span id="49">  49</span>
<span id="50">  50</span>
<span id="51">  51</span>
<span id="52">  52</span>
<span id="53">  53</span>
<span id="54">  54</span>
<span id="55">  55</span>
<span id="56">  56</span>
<span id="57">  57</span>
<span id="58">  58</span>
<span id="59">  59</span>
<span id="60">  60</span>
<span id="61">  61</span>
<span id="62">  62</span>
<span id="63">  63</span>
<span id="64">  64</span>
<span id="65">  65</span>
<span id="66">  66</span>
<span id="67">  67</span>
<span id="68">  68</span>
<span id="69">  69</span>
<span id="70">  70</span>
<span id="71">  71</span>
<span id="72">  72</span>
<span id="73">  73</span>
<span id="74">  74</span>
<span id="75">  75</span>
<span id="76">  76</span>
<span id="77">  77</span>
<span id="78">  78</span>
<span id="79">  79</span>
<span id="80">  80</span>
<span id="81">  81</span>
<span id="82">  82</span>
<span id="83">  83</span>
<span id="84">  84</span>
<span id="85">  85</span>
<span id="86">  86</span>
<span id="87">  87</span>
<span id="88">  88</span>
<span id="89">  89</span>
<span id="90">  90</span>
<span id="91">  91</span>
<span id="92">  92</span>
<span id="93">  93</span>
<span id="94">  94</span>
<span id="95">  95</span>
<span id="96">  96</span>
<span id="97">  97</span>
<span id="98">  98</span>
<span id="99">  99</span>
<span id="100"> 100</span>
<span id="101"> 101</span>
<span id="102"> 102</span>
<span id="103"> 103</span>
<span id="104"> 104</span>
<span id="105"> 105</span>
<span id="106"> 106</span>
<span id="107"> 107</span>
<span id="108"> 108</span>
<span id="109"> 109</span>
<span id="110"> 110</span>
<span id="111"> 111</span>
<span id="112"> 112</span>
<span id="113"> 113</span>
<span id="114"> 114</span>
<span id="115"> 115</span>
<span id="116"> 116</span>
<span id="117"> 117</span>
<span id="118"> 118</span>
<span id="119"> 119</span>
<span id="120"> 120</span>
<span id="121"> 121</span>
<span id="122"> 122</span>
<span id="123"> 123</span>
<span id="124"> 124</span>
<span id="125"> 125</span>
<span id="126"> 126</span>
<span id="127"> 127</span>
<span id="128"> 128</span>
<span id="129"> 129</span>
<span id="130"> 130</span>
<span id="131"> 131</span>
<span id="132"> 132</span>
<span id="133"> 133</span>
<span id="134"> 134</span>
<span id="135"> 135</span>
<span id="136"> 136</span>
<span id="137"> 137</span>
<span id="138"> 138</span>
<span id="139"> 139</span>
<span id="140"> 140</span>
<span id="141"> 141</span>
<span id="142"> 142</span>
<span id="143"> 143</span>
<span id="144"> 144</span>
<span id="145"> 145</span>
<span id="146"> 146</span>
<span id="147"> 147</span>
<span id="148"> 148</span>
<span id="149"> 149</span>
<span id="150"> 150</span>
<span id="151"> 151</span>
<span id="152"> 152</span>
<span id="153"> 153</span>
<span id="154"> 154</span>
<span id="155"> 155</span>
<span id="156"> 156</span>
<span id="157"> 157</span>
<span id="158"> 158</span>
<span id="159"> 159</span>
<span id="160"> 160</span>
<span id="161"> 161</span>
<span id="162"> 162</span>
<span id="163"> 163</span>
<span id="164"> 164</span>
<span id="165"> 165</span>
<span id="166"> 166</span>
<span id="167"> 167</span>
<span id="168"> 168</span>
<span id="169"> 169</span>
<span id="170"> 170</span>
<span id="171"> 171</span>
<span id="172"> 172</span>
<span id="173"> 173</span>
<span id="174"> 174</span>
<span id="175"> 175</span>
<span id="176"> 176</span>
<span id="177"> 177</span>
<span id="178"> 178</span>
<span id="179"> 179</span>
<span id="180"> 180</span>
<span id="181"> 181</span>
<span id="182"> 182</span>
<span id="183"> 183</span>
<span id="184"> 184</span>
<span id="185"> 185</span>
<span id="186"> 186</span>
<span id="187"> 187</span>
<span id="188"> 188</span>
<span id="189"> 189</span>
<span id="190"> 190</span>
<span id="191"> 191</span>
<span id="192"> 192</span>
<span id="193"> 193</span>
<span id="194"> 194</span>
<span id="195"> 195</span>
<span id="196"> 196</span>
<span id="197"> 197</span>
<span id="198"> 198</span>
<span id="199"> 199</span>
<span id="200"> 200</span>
<span id="201"> 201</span>
<span id="202"> 202</span>
<span id="203"> 203</span>
<span id="204"> 204</span>
<span id="205"> 205</span>
<span id="206"> 206</span>
<span id="207"> 207</span>
<span id="208"> 208</span>
<span id="209"> 209</span>
<span id="210"> 210</span>
<span id="211"> 211</span>
<span id="212"> 212</span>
<span id="213"> 213</span>
<span id="214"> 214</span>
<span id="215"> 215</span>
<span id="216"> 216</span>
<span id="217"> 217</span>
<span id="218"> 218</span>
<span id="219"> 219</span>
<span id="220"> 220</span>
<span id="221"> 221</span>
<span id="222"> 222</span>
<span id="223"> 223</span>
<span id="224"> 224</span>
<span id="225"> 225</span>
<span id="226"> 226</span>
<span id="227"> 227</span>
<span id="228"> 228</span>
<span id="229"> 229</span>
<span id="230"> 230</span>
<span id="231"> 231</span>
<span id="232"> 232</span>
<span id="233"> 233</span>
<span id="234"> 234</span>
<span id="235"> 235</span>
<span id="236"> 236</span>
<span id="237"> 237</span>
<span id="238"> 238</span>
<span id="239"> 239</span>
<span id="240"> 240</span>
<span id="241"> 241</span>
<span id="242"> 242</span>
<span id="243"> 243</span>
<span id="244"> 244</span>
<span id="245"> 245</span>
<span id="246"> 246</span>
<span id="247"> 247</span>
<span id="248"> 248</span>
<span id="249"> 249</span>
<span id="250"> 250</span>
<span id="251"> 251</span>
<span id="252"> 252</span>
<span id="253"> 253</span>
<span id="254"> 254</span>
<span id="255"> 255</span>
<span id="256"> 256</span>
<span id="257"> 257</span>
<span id="258"> 258</span>
<span id="259"> 259</span>
<span id="260"> 260</span>
<span id="261"> 261</span>
<span id="262"> 262</span>
<span id="263"> 263</span>
<span id="264"> 264</span>
<span id="265"> 265</span>
<span id="266"> 266</span>
<span id="267"> 267</span>
<span id="268"> 268</span>
<span id="269"> 269</span>
<span id="270"> 270</span>
<span id="271"> 271</span>
<span id="272"> 272</span>
<span id="273"> 273</span>
<span id="274"> 274</span>
<span id="275"> 275</span>
<span id="276"> 276</span>
<span id="277"> 277</span>
<span id="278"> 278</span>
<span id="279"> 279</span>
<span id="280"> 280</span>
<span id="281"> 281</span>
<span id="282"> 282</span>
<span id="283"> 283</span>
<span id="284"> 284</span>
<span id="285"> 285</span>
<span id="286"> 286</span>
<span id="287"> 287</span>
<span id="288"> 288</span>
<span id="289"> 289</span>
<span id="290"> 290</span>
<span id="291"> 291</span>
<span id="292"> 292</span>
<span id="293"> 293</span>
<span id="294"> 294</span>
<span id="295"> 295</span>
<span id="296"> 296</span>
<span id="297"> 297</span>
<span id="298"> 298</span>
<span id="299"> 299</span>
<span id="300"> 300</span>
<span id="301"> 301</span>
<span id="302"> 302</span>
<span id="303"> 303</span>
<span id="304"> 304</span>
<span id="305"> 305</span>
<span id="306"> 306</span>
<span id="307"> 307</span>
<span id="308"> 308</span>
<span id="309"> 309</span>
<span id="310"> 310</span>
<span id="311"> 311</span>
<span id="312"> 312</span>
<span id="313"> 313</span>
<span id="314"> 314</span>
<span id="315"> 315</span>
<span id="316"> 316</span>
<span id="317"> 317</span>
<span id="318"> 318</span>
<span id="319"> 319</span>
<span id="320"> 320</span>
<span id="321"> 321</span>
<span id="322"> 322</span>
<span id="323"> 323</span>
<span id="324"> 324</span>
<span id="325"> 325</span>
<span id="326"> 326</span>
<span id="327"> 327</span>
<span id="328"> 328</span>
<span id="329"> 329</span>
<span id="330"> 330</span>
<span id="331"> 331</span>
<span id="332"> 332</span>
<span id="333"> 333</span>
<span id="334"> 334</span>
<span id="335"> 335</span>
<span id="336"> 336</span>
<span id="337"> 337</span>
<span id="338"> 338</span>
<span id="339"> 339</span>
<span id="340"> 340</span>
<span id="341"> 341</span>
<span id="342"> 342</span>
<span id="343"> 343</span>
<span id="344"> 344</span>
<span id="345"> 345</span>
<span id="346"> 346</span>
<span id="347"> 347</span>
<span id="348"> 348</span>
<span id="349"> 349</span>
<span id="350"> 350</span>
<span id="351"> 351</span>
<span id="352"> 352</span>
<span id="353"> 353</span>
<span id="354"> 354</span>
<span id="355"> 355</span>
<span id="356"> 356</span>
<span id="357"> 357</span>
<span id="358"> 358</span>
<span id="359"> 359</span>
<span id="360"> 360</span>
<span id="361"> 361</span>
<span id="362"> 362</span>
<span id="363"> 363</span>
<span id="364"> 364</span>
<span id="365"> 365</span>
<span id="366"> 366</span>
<span id="367"> 367</span>
<span id="368"> 368</span>
<span id="369"> 369</span>
<span id="370"> 370</span>
<span id="371"> 371</span>
<span id="372"> 372</span>
<span id="373"> 373</span>
<span id="374"> 374</span>
<span id="375"> 375</span>
<span id="376"> 376</span>
<span id="377"> 377</span>
<span id="378"> 378</span>
<span id="379"> 379</span>
<span id="380"> 380</span>
<span id="381"> 381</span>
<span id="382"> 382</span>
<span id="383"> 383</span>
<span id="384"> 384</span>
<span id="385"> 385</span>
<span id="386"> 386</span>
<span id="387"> 387</span>
<span id="388"> 388</span>
<span id="389"> 389</span>
<span id="390"> 390</span>
<span id="391"> 391</span>
<span id="392"> 392</span>
<span id="393"> 393</span>
<span id="394"> 394</span>
<span id="395"> 395</span>
<span id="396"> 396</span>
<span id="397"> 397</span>
<span id="398"> 398</span>
<span id="399"> 399</span>
<span id="400"> 400</span>
<span id="401"> 401</span>
<span id="402"> 402</span>
<span id="403"> 403</span>
<span id="404"> 404</span>
<span id="405"> 405</span>
<span id="406"> 406</span>
<span id="407"> 407</span>
<span id="408"> 408</span>
<span id="409"> 409</span>
<span id="410"> 410</span>
<span id="411"> 411</span>
<span id="412"> 412</span>
<span id="413"> 413</span>
<span id="414"> 414</span>
<span id="415"> 415</span>
<span id="416"> 416</span>
<span id="417"> 417</span>
<span id="418"> 418</span>
<span id="419"> 419</span>
<span id="420"> 420</span>
<span id="421"> 421</span>
<span id="422"> 422</span>
<span id="423"> 423</span>
<span id="424"> 424</span>
<span id="425"> 425</span>
<span id="426"> 426</span>
<span id="427"> 427</span>
<span id="428"> 428</span>
<span id="429"> 429</span>
<span id="430"> 430</span>
<span id="431"> 431</span>
<span id="432"> 432</span>
<span id="433"> 433</span>
<span id="434"> 434</span>
<span id="435"> 435</span>
<span id="436"> 436</span>
<span id="437"> 437</span>
<span id="438"> 438</span>
<span id="439"> 439</span>
<span id="440"> 440</span>
<span id="441"> 441</span>
<span id="442"> 442</span>
<span id="443"> 443</span>
<span id="444"> 444</span>
<span id="445"> 445</span>
<span id="446"> 446</span>
<span id="447"> 447</span>
<span id="448"> 448</span>
<span id="449"> 449</span>
<span id="450"> 450</span>
<span id="451"> 451</span>
<span id="452"> 452</span>
<span id="453"> 453</span>
<span id="454"> 454</span>
<span id="455"> 455</span>
<span id="456"> 456</span>
<span id="457"> 457</span>
<span id="458"> 458</span>
<span id="459"> 459</span>
<span id="460"> 460</span>
<span id="461"> 461</span>
<span id="462"> 462</span>
<span id="463"> 463</span>
<span id="464"> 464</span>
<span id="465"> 465</span>
<span id="466"> 466</span>
<span id="467"> 467</span>
<span id="468"> 468</span>
<span id="469"> 469</span>
<span id="470"> 470</span>
<span id="471"> 471</span>
<span id="472"> 472</span>
<span id="473"> 473</span>
<span id="474"> 474</span>
<span id="475"> 475</span>
<span id="476"> 476</span>
<span id="477"> 477</span>
<span id="478"> 478</span>
<span id="479"> 479</span>
<span id="480"> 480</span>
<span id="481"> 481</span>
<span id="482"> 482</span>
<span id="483"> 483</span>
<span id="484"> 484</span>
<span id="485"> 485</span>
<span id="486"> 486</span>
<span id="487"> 487</span>
<span id="488"> 488</span>
<span id="489"> 489</span>
<span id="490"> 490</span>
<span id="491"> 491</span>
<span id="492"> 492</span>
<span id="493"> 493</span>
<span id="494"> 494</span>
<span id="495"> 495</span>
<span id="496"> 496</span>
<span id="497"> 497</span>
<span id="498"> 498</span>
<span id="499"> 499</span>
<span id="500"> 500</span>
<span id="501"> 501</span>
<span id="502"> 502</span>
<span id="503"> 503</span>
<span id="504"> 504</span>
<span id="505"> 505</span>
<span id="506"> 506</span>
<span id="507"> 507</span>
<span id="508"> 508</span>
<span id="509"> 509</span>
<span id="510"> 510</span>
<span id="511"> 511</span>
<span id="512"> 512</span>
<span id="513"> 513</span>
<span id="514"> 514</span>
<span id="515"> 515</span>
<span id="516"> 516</span>
<span id="517"> 517</span>
<span id="518"> 518</span>
<span id="519"> 519</span>
<span id="520"> 520</span>
<span id="521"> 521</span>
<span id="522"> 522</span>
<span id="523"> 523</span>
<span id="524"> 524</span>
<span id="525"> 525</span>
<span id="526"> 526</span>
<span id="527"> 527</span>
<span id="528"> 528</span>
<span id="529"> 529</span>
<span id="530"> 530</span>
<span id="531"> 531</span>
<span id="532"> 532</span>
<span id="533"> 533</span>
<span id="534"> 534</span>
<span id="535"> 535</span>
<span id="536"> 536</span>
<span id="537"> 537</span>
<span id="538"> 538</span>
<span id="539"> 539</span>
<span id="540"> 540</span>
<span id="541"> 541</span>
<span id="542"> 542</span>
<span id="543"> 543</span>
<span id="544"> 544</span>
<span id="545"> 545</span>
<span id="546"> 546</span>
<span id="547"> 547</span>
<span id="548"> 548</span>
<span id="549"> 549</span>
<span id="550"> 550</span>
<span id="551"> 551</span>
<span id="552"> 552</span>
<span id="553"> 553</span>
<span id="554"> 554</span>
<span id="555"> 555</span>
<span id="556"> 556</span>
<span id="557"> 557</span>
<span id="558"> 558</span>
<span id="559"> 559</span>
<span id="560"> 560</span>
<span id="561"> 561</span>
<span id="562"> 562</span>
<span id="563"> 563</span>
<span id="564"> 564</span>
<span id="565"> 565</span>
<span id="566"> 566</span>
<span id="567"> 567</span>
<span id="568"> 568</span>
<span id="569"> 569</span>
<span id="570"> 570</span>
<span id="571"> 571</span>
<span id="572"> 572</span>
<span id="573"> 573</span>
<span id="574"> 574</span>
<span id="575"> 575</span>
<span id="576"> 576</span>
<span id="577"> 577</span>
<span id="578"> 578</span>
<span id="579"> 579</span>
<span id="580"> 580</span>
<span id="581"> 581</span>
<span id="582"> 582</span>
<span id="583"> 583</span>
<span id="584"> 584</span>
<span id="585"> 585</span>
<span id="586"> 586</span>
<span id="587"> 587</span>
<span id="588"> 588</span>
<span id="589"> 589</span>
<span id="590"> 590</span>
<span id="591"> 591</span>
<span id="592"> 592</span>
<span id="593"> 593</span>
<span id="594"> 594</span>
<span id="595"> 595</span>
<span id="596"> 596</span>
<span id="597"> 597</span>
<span id="598"> 598</span>
<span id="599"> 599</span>
<span id="600"> 600</span>
<span id="601"> 601</span>
<span id="602"> 602</span>
<span id="603"> 603</span>
<span id="604"> 604</span>
<span id="605"> 605</span>
<span id="606"> 606</span>
<span id="607"> 607</span>
<span id="608"> 608</span>
<span id="609"> 609</span>
<span id="610"> 610</span>
<span id="611"> 611</span>
<span id="612"> 612</span>
<span id="613"> 613</span>
<span id="614"> 614</span>
<span id="615"> 615</span>
<span id="616"> 616</span>
<span id="617"> 617</span>
<span id="618"> 618</span>
<span id="619"> 619</span>
<span id="620"> 620</span>
<span id="621"> 621</span>
<span id="622"> 622</span>
<span id="623"> 623</span>
<span id="624"> 624</span>
<span id="625"> 625</span>
<span id="626"> 626</span>
<span id="627"> 627</span>
<span id="628"> 628</span>
<span id="629"> 629</span>
<span id="630"> 630</span>
<span id="631"> 631</span>
<span id="632"> 632</span>
<span id="633"> 633</span>
<span id="634"> 634</span>
<span id="635"> 635</span>
<span id="636"> 636</span>
<span id="637"> 637</span>
<span id="638"> 638</span>
<span id="639"> 639</span>
<span id="640"> 640</span>
<span id="641"> 641</span>
<span id="642"> 642</span>
<span id="643"> 643</span>
<span id="644"> 644</span>
<span id="645"> 645</span>
<span id="646"> 646</span>
<span id="647"> 647</span>
<span id="648"> 648</span>
<span id="649"> 649</span>
<span id="650"> 650</span>
<span id="651"> 651</span>
<span id="652"> 652</span>
<span id="653"> 653</span>
<span id="654"> 654</span>
<span id="655"> 655</span>
<span id="656"> 656</span>
<span id="657"> 657</span>
<span id="658"> 658</span>
<span id="659"> 659</span>
<span id="660"> 660</span>
<span id="661"> 661</span>
<span id="662"> 662</span>
<span id="663"> 663</span>
<span id="664"> 664</span>
<span id="665"> 665</span>
<span id="666"> 666</span>
<span id="667"> 667</span>
<span id="668"> 668</span>
<span id="669"> 669</span>
<span id="670"> 670</span>
<span id="671"> 671</span>
<span id="672"> 672</span>
<span id="673"> 673</span>
<span id="674"> 674</span>
<span id="675"> 675</span>
<span id="676"> 676</span>
<span id="677"> 677</span>
<span id="678"> 678</span>
<span id="679"> 679</span>
<span id="680"> 680</span>
<span id="681"> 681</span>
<span id="682"> 682</span>
<span id="683"> 683</span>
<span id="684"> 684</span>
<span id="685"> 685</span>
<span id="686"> 686</span>
<span id="687"> 687</span>
<span id="688"> 688</span>
<span id="689"> 689</span>
<span id="690"> 690</span>
<span id="691"> 691</span>
<span id="692"> 692</span>
<span id="693"> 693</span>
<span id="694"> 694</span>
<span id="695"> 695</span>
<span id="696"> 696</span>
<span id="697"> 697</span>
<span id="698"> 698</span>
<span id="699"> 699</span>
<span id="700"> 700</span>
<span id="701"> 701</span>
<span id="702"> 702</span>
<span id="703"> 703</span>
<span id="704"> 704</span>
<span id="705"> 705</span>
<span id="706"> 706</span>
<span id="707"> 707</span>
<span id="708"> 708</span>
<span id="709"> 709</span>
<span id="710"> 710</span>
<span id="711"> 711</span>
<span id="712"> 712</span>
<span id="713"> 713</span>
<span id="714"> 714</span>
<span id="715"> 715</span>
<span id="716"> 716</span>
<span id="717"> 717</span>
<span id="718"> 718</span>
<span id="719"> 719</span>
<span id="720"> 720</span>
<span id="721"> 721</span>
<span id="722"> 722</span>
<span id="723"> 723</span>
<span id="724"> 724</span>
<span id="725"> 725</span>
<span id="726"> 726</span>
<span id="727"> 727</span>
<span id="728"> 728</span>
<span id="729"> 729</span>
<span id="730"> 730</span>
<span id="731"> 731</span>
<span id="732"> 732</span>
<span id="733"> 733</span>
<span id="734"> 734</span>
<span id="735"> 735</span>
<span id="736"> 736</span>
<span id="737"> 737</span>
<span id="738"> 738</span>
<span id="739"> 739</span>
<span id="740"> 740</span>
<span id="741"> 741</span>
<span id="742"> 742</span>
<span id="743"> 743</span>
<span id="744"> 744</span>
<span id="745"> 745</span>
<span id="746"> 746</span>
<span id="747"> 747</span>
<span id="748"> 748</span>
<span id="749"> 749</span>
<span id="750"> 750</span>
<span id="751"> 751</span>
<span id="752"> 752</span>
<span id="753"> 753</span>
<span id="754"> 754</span>
<span id="755"> 755</span>
<span id="756"> 756</span>
<span id="757"> 757</span>
<span id="758"> 758</span>
<span id="759"> 759</span>
<span id="760"> 760</span>
<span id="761"> 761</span>
<span id="762"> 762</span>
<span id="763"> 763</span>
<span id="764"> 764</span>
<span id="765"> 765</span>
<span id="766"> 766</span>
<span id="767"> 767</span>
<span id="768"> 768</span>
<span id="769"> 769</span>
<span id="770"> 770</span>
<span id="771"> 771</span>
<span id="772"> 772</span>
<span id="773"> 773</span>
<span id="774"> 774</span>
<span id="775"> 775</span>
<span id="776"> 776</span>
<span id="777"> 777</span>
<span id="778"> 778</span>
<span id="779"> 779</span>
<span id="780"> 780</span>
<span id="781"> 781</span>
<span id="782"> 782</span>
<span id="783"> 783</span>
<span id="784"> 784</span>
<span id="785"> 785</span>
<span id="786"> 786</span>
<span id="787"> 787</span>
<span id="788"> 788</span>
<span id="789"> 789</span>
<span id="790"> 790</span>
<span id="791"> 791</span>
<span id="792"> 792</span>
<span id="793"> 793</span>
<span id="794"> 794</span>
<span id="795"> 795</span>
<span id="796"> 796</span>
<span id="797"> 797</span>
<span id="798"> 798</span>
<span id="799"> 799</span>
<span id="800"> 800</span>
<span id="801"> 801</span>
<span id="802"> 802</span>
<span id="803"> 803</span>
<span id="804"> 804</span>
<span id="805"> 805</span>
<span id="806"> 806</span>
<span id="807"> 807</span>
<span id="808"> 808</span>
<span id="809"> 809</span>
<span id="810"> 810</span>
<span id="811"> 811</span>
<span id="812"> 812</span>
<span id="813"> 813</span>
<span id="814"> 814</span>
<span id="815"> 815</span>
<span id="816"> 816</span>
<span id="817"> 817</span>
<span id="818"> 818</span>
<span id="819"> 819</span>
<span id="820"> 820</span>
<span id="821"> 821</span>
<span id="822"> 822</span>
<span id="823"> 823</span>
<span id="824"> 824</span>
<span id="825"> 825</span>
<span id="826"> 826</span>
<span id="827"> 827</span>
<span id="828"> 828</span>
<span id="829"> 829</span>
<span id="830"> 830</span>
<span id="831"> 831</span>
<span id="832"> 832</span>
<span id="833"> 833</span>
<span id="834"> 834</span>
<span id="835"> 835</span>
<span id="836"> 836</span>
<span id="837"> 837</span>
<span id="838"> 838</span>
<span id="839"> 839</span>
<span id="840"> 840</span>
<span id="841"> 841</span>
<span id="842"> 842</span>
<span id="843"> 843</span>
<span id="844"> 844</span>
<span id="845"> 845</span>
<span id="846"> 846</span>
<span id="847"> 847</span>
<span id="848"> 848</span>
<span id="849"> 849</span>
<span id="850"> 850</span>
<span id="851"> 851</span>
<span id="852"> 852</span>
<span id="853"> 853</span>
<span id="854"> 854</span>
<span id="855"> 855</span>
<span id="856"> 856</span>
<span id="857"> 857</span>
<span id="858"> 858</span>
<span id="859"> 859</span>
<span id="860"> 860</span>
<span id="861"> 861</span>
<span id="862"> 862</span>
<span id="863"> 863</span>
<span id="864"> 864</span>
<span id="865"> 865</span>
<span id="866"> 866</span>
<span id="867"> 867</span>
<span id="868"> 868</span>
<span id="869"> 869</span>
<span id="870"> 870</span>
<span id="871"> 871</span>
<span id="872"> 872</span>
<span id="873"> 873</span>
<span id="874"> 874</span>
<span id="875"> 875</span>
<span id="876"> 876</span>
<span id="877"> 877</span>
<span id="878"> 878</span>
<span id="879"> 879</span>
<span id="880"> 880</span>
<span id="881"> 881</span>
<span id="882"> 882</span>
<span id="883"> 883</span>
<span id="884"> 884</span>
<span id="885"> 885</span>
<span id="886"> 886</span>
<span id="887"> 887</span>
<span id="888"> 888</span>
<span id="889"> 889</span>
<span id="890"> 890</span>
<span id="891"> 891</span>
<span id="892"> 892</span>
<span id="893"> 893</span>
<span id="894"> 894</span>
<span id="895"> 895</span>
<span id="896"> 896</span>
<span id="897"> 897</span>
<span id="898"> 898</span>
<span id="899"> 899</span>
<span id="900"> 900</span>
<span id="901"> 901</span>
<span id="902"> 902</span>
<span id="903"> 903</span>
<span id="904"> 904</span>
<span id="905"> 905</span>
<span id="906"> 906</span>
<span id="907"> 907</span>
<span id="908"> 908</span>
<span id="909"> 909</span>
<span id="910"> 910</span>
<span id="911"> 911</span>
<span id="912"> 912</span>
<span id="913"> 913</span>
<span id="914"> 914</span>
<span id="915"> 915</span>
<span id="916"> 916</span>
<span id="917"> 917</span>
<span id="918"> 918</span>
<span id="919"> 919</span>
<span id="920"> 920</span>
<span id="921"> 921</span>
<span id="922"> 922</span>
<span id="923"> 923</span>
<span id="924"> 924</span>
<span id="925"> 925</span>
<span id="926"> 926</span>
<span id="927"> 927</span>
<span id="928"> 928</span>
<span id="929"> 929</span>
<span id="930"> 930</span>
<span id="931"> 931</span>
<span id="932"> 932</span>
<span id="933"> 933</span>
<span id="934"> 934</span>
<span id="935"> 935</span>
<span id="936"> 936</span>
<span id="937"> 937</span>
<span id="938"> 938</span>
<span id="939"> 939</span>
<span id="940"> 940</span>
<span id="941"> 941</span>
<span id="942"> 942</span>
<span id="943"> 943</span>
<span id="944"> 944</span>
<span id="945"> 945</span>
<span id="946"> 946</span>
<span id="947"> 947</span>
<span id="948"> 948</span>
<span id="949"> 949</span>
<span id="950"> 950</span>
<span id="951"> 951</span>
<span id="952"> 952</span>
<span id="953"> 953</span>
<span id="954"> 954</span>
<span id="955"> 955</span>
<span id="956"> 956</span>
<span id="957"> 957</span>
<span id="958"> 958</span>
<span id="959"> 959</span>
<span id="960"> 960</span>
<span id="961"> 961</span>
<span id="962"> 962</span>
<span id="963"> 963</span>
<span id="964"> 964</span>
<span id="965"> 965</span>
<span id="966"> 966</span>
<span id="967"> 967</span>
<span id="968"> 968</span>
<span id="969"> 969</span>
<span id="970"> 970</span>
<span id="971"> 971</span>
<span id="972"> 972</span>
<span id="973"> 973</span>
<span id="974"> 974</span>
<span id="975"> 975</span>
<span id="976"> 976</span>
<span id="977"> 977</span>
<span id="978"> 978</span>
<span id="979"> 979</span>
<span id="980"> 980</span>
<span id="981"> 981</span>
<span id="982"> 982</span>
<span id="983"> 983</span>
<span id="984"> 984</span>
<span id="985"> 985</span>
<span id="986"> 986</span>
<span id="987"> 987</span>
<span id="988"> 988</span>
<span id="989"> 989</span>
<span id="990"> 990</span>
<span id="991"> 991</span>
<span id="992"> 992</span>
<span id="993"> 993</span>
<span id="994"> 994</span>
<span id="995"> 995</span>
<span id="996"> 996</span>
<span id="997"> 997</span>
<span id="998"> 998</span>
<span id="999"> 999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
<span id="1021">1021</span>
<span id="1022">1022</span>
<span id="1023">1023</span>
<span id="1024">1024</span>
<span id="1025">1025</span>
<span id="1026">1026</span>
<span id="1027">1027</span>
<span id="1028">1028</span>
<span id="1029">1029</span>
<span id="1030">1030</span>
<span id="1031">1031</span>
<span id="1032">1032</span>
<span id="1033">1033</span>
<span id="1034">1034</span>
<span id="1035">1035</span>
<span id="1036">1036</span>
<span id="1037">1037</span>
<span id="1038">1038</span>
<span id="1039">1039</span>
<span id="1040">1040</span>
<span id="1041">1041</span>
<span id="1042">1042</span>
<span id="1043">1043</span>
<span id="1044">1044</span>
<span id="1045">1045</span>
<span id="1046">1046</span>
<span id="1047">1047</span>
<span id="1048">1048</span>
<span id="1049">1049</span>
<span id="1050">1050</span>
<span id="1051">1051</span>
<span id="1052">1052</span>
<span id="1053">1053</span>
<span id="1054">1054</span>
<span id="1055">1055</span>
<span id="1056">1056</span>
<span id="1057">1057</span>
<span id="1058">1058</span>
<span id="1059">1059</span>
<span id="1060">1060</span>
<span id="1061">1061</span>
<span id="1062">1062</span>
<span id="1063">1063</span>
<span id="1064">1064</span>
<span id="1065">1065</span>
<span id="1066">1066</span>
<span id="1067">1067</span>
<span id="1068">1068</span>
<span id="1069">1069</span>
<span id="1070">1070</span>
<span id="1071">1071</span>
<span id="1072">1072</span>
<span id="1073">1073</span>
<span id="1074">1074</span>
<span id="1075">1075</span>
<span id="1076">1076</span>
<span id="1077">1077</span>
<span id="1078">1078</span>
<span id="1079">1079</span>
<span id="1080">1080</span>
<span id="1081">1081</span>
<span id="1082">1082</span>
<span id="1083">1083</span>
<span id="1084">1084</span>
<span id="1085">1085</span>
<span id="1086">1086</span>
<span id="1087">1087</span>
<span id="1088">1088</span>
<span id="1089">1089</span>
<span id="1090">1090</span>
<span id="1091">1091</span>
<span id="1092">1092</span>
<span id="1093">1093</span>
<span id="1094">1094</span>
<span id="1095">1095</span>
<span id="1096">1096</span>
<span id="1097">1097</span>
<span id="1098">1098</span>
<span id="1099">1099</span>
<span id="1100">1100</span>
<span id="1101">1101</span>
<span id="1102">1102</span>
<span id="1103">1103</span>
<span id="1104">1104</span>
<span id="1105">1105</span>
<span id="1106">1106</span>
<span id="1107">1107</span>
<span id="1108">1108</span>
<span id="1109">1109</span>
<span id="1110">1110</span>
<span id="1111">1111</span>
<span id="1112">1112</span>
<span id="1113">1113</span>
<span id="1114">1114</span>
<span id="1115">1115</span>
<span id="1116">1116</span>
<span id="1117">1117</span>
<span id="1118">1118</span>
<span id="1119">1119</span>
<span id="1120">1120</span>
<span id="1121">1121</span>
<span id="1122">1122</span>
<span id="1123">1123</span>
<span id="1124">1124</span>
<span id="1125">1125</span>
<span id="1126">1126</span>
<span id="1127">1127</span>
<span id="1128">1128</span>
<span id="1129">1129</span>
<span id="1130">1130</span>
<span id="1131">1131</span>
<span id="1132">1132</span>
<span id="1133">1133</span>
<span id="1134">1134</span>
<span id="1135">1135</span>
<span id="1136">1136</span>
<span id="1137">1137</span>
<span id="1138">1138</span>
<span id="1139">1139</span>
<span id="1140">1140</span>
<span id="1141">1141</span>
<span id="1142">1142</span>
<span id="1143">1143</span>
<span id="1144">1144</span>
<span id="1145">1145</span>
<span id="1146">1146</span>
<span id="1147">1147</span>
<span id="1148">1148</span>
<span id="1149">1149</span>
<span id="1150">1150</span>
<span id="1151">1151</span>
<span id="1152">1152</span>
<span id="1153">1153</span>
<span id="1154">1154</span>
<span id="1155">1155</span>
<span id="1156">1156</span>
<span id="1157">1157</span>
<span id="1158">1158</span>
<span id="1159">1159</span>
<span id="1160">1160</span>
<span id="1161">1161</span>
<span id="1162">1162</span>
<span id="1163">1163</span>
<span id="1164">1164</span>
<span id="1165">1165</span>
<span id="1166">1166</span>
<span id="1167">1167</span>
<span id="1168">1168</span>
<span id="1169">1169</span>
<span id="1170">1170</span>
<span id="1171">1171</span>
<span id="1172">1172</span>
<span id="1173">1173</span>
<span id="1174">1174</span>
<span id="1175">1175</span>
<span id="1176">1176</span>
<span id="1177">1177</span>
<span id="1178">1178</span>
<span id="1179">1179</span>
<span id="1180">1180</span>
<span id="1181">1181</span>
<span id="1182">1182</span>
<span id="1183">1183</span>
<span id="1184">1184</span>
<span id="1185">1185</span>
<span id="1186">1186</span>
<span id="1187">1187</span>
<span id="1188">1188</span>
<span id="1189">1189</span>
<span id="1190">1190</span>
<span id="1191">1191</span>
<span id="1192">1192</span>
<span id="1193">1193</span>
<span id="1194">1194</span>
<span id="1195">1195</span>
<span id="1196">1196</span>
<span id="1197">1197</span>
<span id="1198">1198</span>
<span id="1199">1199</span>
<span id="1200">1200</span>
<span id="1201">1201</span>
<span id="1202">1202</span>
<span id="1203">1203</span>
<span id="1204">1204</span>
<span id="1205">1205</span>
<span id="1206">1206</span>
<span id="1207">1207</span>
<span id="1208">1208</span>
<span id="1209">1209</span>
<span id="1210">1210</span>
<span id="1211">1211</span>
<span id="1212">1212</span>
<span id="1213">1213</span>
<span id="1214">1214</span>
<span id="1215">1215</span>
<span id="1216">1216</span>
<span id="1217">1217</span>
<span id="1218">1218</span>
<span id="1219">1219</span>
<span id="1220">1220</span>
<span id="1221">1221</span>
<span id="1222">1222</span>
<span id="1223">1223</span>
<span id="1224">1224</span>
<span id="1225">1225</span>
<span id="1226">1226</span>
<span id="1227">1227</span>
<span id="1228">1228</span>
<span id="1229">1229</span>
<span id="1230">1230</span>
<span id="1231">1231</span>
<span id="1232">1232</span>
<span id="1233">1233</span>
<span id="1234">1234</span>
<span id="1235">1235</span>
<span id="1236">1236</span>
<span id="1237">1237</span>
<span id="1238">1238</span>
<span id="1239">1239</span>
<span id="1240">1240</span>
<span id="1241">1241</span>
<span id="1242">1242</span>
<span id="1243">1243</span>
<span id="1244">1244</span>
<span id="1245">1245</span>
<span id="1246">1246</span>
<span id="1247">1247</span>
<span id="1248">1248</span>
<span id="1249">1249</span>
<span id="1250">1250</span>
<span id="1251">1251</span>
<span id="1252">1252</span>
<span id="1253">1253</span>
<span id="1254">1254</span>
<span id="1255">1255</span>
<span id="1256">1256</span>
<span id="1257">1257</span>
<span id="1258">1258</span>
<span id="1259">1259</span>
<span id="1260">1260</span>
<span id="1261">1261</span>
<span id="1262">1262</span>
<span id="1263">1263</span>
<span id="1264">1264</span>
<span id="1265">1265</span>
<span id="1266">1266</span>
<span id="1267">1267</span>
<span id="1268">1268</span>
<span id="1269">1269</span>
<span id="1270">1270</span>
<span id="1271">1271</span>
<span id="1272">1272</span>
<span id="1273">1273</span>
<span id="1274">1274</span>
<span id="1275">1275</span>
<span id="1276">1276</span>
<span id="1277">1277</span>
<span id="1278">1278</span>
<span id="1279">1279</span>
<span id="1280">1280</span>
<span id="1281">1281</span>
<span id="1282">1282</span>
<span id="1283">1283</span>
<span id="1284">1284</span>
<span id="1285">1285</span>
<span id="1286">1286</span>
<span id="1287">1287</span>
<span id="1288">1288</span>
<span id="1289">1289</span>
<span id="1290">1290</span>
<span id="1291">1291</span>
<span id="1292">1292</span>
<span id="1293">1293</span>
<span id="1294">1294</span>
<span id="1295">1295</span>
<span id="1296">1296</span>
<span id="1297">1297</span>
<span id="1298">1298</span>
<span id="1299">1299</span>
<span id="1300">1300</span>
<span id="1301">1301</span>
<span id="1302">1302</span>
<span id="1303">1303</span>
<span id="1304">1304</span>
<span id="1305">1305</span>
<span id="1306">1306</span>
<span id="1307">1307</span>
<span id="1308">1308</span>
<span id="1309">1309</span>
<span id="1310">1310</span>
<span id="1311">1311</span>
<span id="1312">1312</span>
<span id="1313">1313</span>
<span id="1314">1314</span>
<span id="1315">1315</span>
<span id="1316">1316</span>
<span id="1317">1317</span>
<span id="1318">1318</span>
<span id="1319">1319</span>
<span id="1320">1320</span>
<span id="1321">1321</span>
<span id="1322">1322</span>
<span id="1323">1323</span>
<span id="1324">1324</span>
<span id="1325">1325</span>
<span id="1326">1326</span>
<span id="1327">1327</span>
<span id="1328">1328</span>
<span id="1329">1329</span>
<span id="1330">1330</span>
<span id="1331">1331</span>
<span id="1332">1332</span>
<span id="1333">1333</span>
<span id="1334">1334</span>
<span id="1335">1335</span>
<span id="1336">1336</span>
<span id="1337">1337</span>
<span id="1338">1338</span>
<span id="1339">1339</span>
<span id="1340">1340</span>
<span id="1341">1341</span>
<span id="1342">1342</span>
<span id="1343">1343</span>
<span id="1344">1344</span>
<span id="1345">1345</span>
<span id="1346">1346</span>
<span id="1347">1347</span>
<span id="1348">1348</span>
<span id="1349">1349</span>
<span id="1350">1350</span>
<span id="1351">1351</span>
<span id="1352">1352</span>
<span id="1353">1353</span>
<span id="1354">1354</span>
<span id="1355">1355</span>
<span id="1356">1356</span>
<span id="1357">1357</span>
<span id="1358">1358</span>
<span id="1359">1359</span>
<span id="1360">1360</span>
<span id="1361">1361</span>
<span id="1362">1362</span>
<span id="1363">1363</span>
<span id="1364">1364</span>
<span id="1365">1365</span>
<span id="1366">1366</span>
<span id="1367">1367</span>
<span id="1368">1368</span>
<span id="1369">1369</span>
<span id="1370">1370</span>
<span id="1371">1371</span>
<span id="1372">1372</span>
<span id="1373">1373</span>
<span id="1374">1374</span>
<span id="1375">1375</span>
<span id="1376">1376</span>
<span id="1377">1377</span>
<span id="1378">1378</span>
<span id="1379">1379</span>
<span id="1380">1380</span>
<span id="1381">1381</span>
<span id="1382">1382</span>
<span id="1383">1383</span>
<span id="1384">1384</span>
<span id="1385">1385</span>
<span id="1386">1386</span>
<span id="1387">1387</span>
<span id="1388">1388</span>
<span id="1389">1389</span>
<span id="1390">1390</span>
<span id="1391">1391</span>
<span id="1392">1392</span>
<span id="1393">1393</span>
<span id="1394">1394</span>
<span id="1395">1395</span>
<span id="1396">1396</span>
<span id="1397">1397</span>
<span id="1398">1398</span>
<span id="1399">1399</span>
<span id="1400">1400</span>
<span id="1401">1401</span>
<span id="1402">1402</span>
<span id="1403">1403</span>
<span id="1404">1404</span>
<span id="1405">1405</span>
<span id="1406">1406</span>
<span id="1407">1407</span>
<span id="1408">1408</span>
<span id="1409">1409</span>
<span id="1410">1410</span>
<span id="1411">1411</span>
<span id="1412">1412</span>
<span id="1413">1413</span>
<span id="1414">1414</span>
<span id="1415">1415</span>
<span id="1416">1416</span>
<span id="1417">1417</span>
<span id="1418">1418</span>
<span id="1419">1419</span>
<span id="1420">1420</span>
<span id="1421">1421</span>
<span id="1422">1422</span>
<span id="1423">1423</span>
<span id="1424">1424</span>
<span id="1425">1425</span>
<span id="1426">1426</span>
<span id="1427">1427</span>
<span id="1428">1428</span>
<span id="1429">1429</span>
<span id="1430">1430</span>
<span id="1431">1431</span>
<span id="1432">1432</span>
<span id="1433">1433</span>
<span id="1434">1434</span>
<span id="1435">1435</span>
<span id="1436">1436</span>
<span id="1437">1437</span>
<span id="1438">1438</span>
<span id="1439">1439</span>
<span id="1440">1440</span>
<span id="1441">1441</span>
<span id="1442">1442</span>
<span id="1443">1443</span>
<span id="1444">1444</span>
<span id="1445">1445</span>
<span id="1446">1446</span>
<span id="1447">1447</span>
<span id="1448">1448</span>
<span id="1449">1449</span>
<span id="1450">1450</span>
<span id="1451">1451</span>
<span id="1452">1452</span>
<span id="1453">1453</span>
<span id="1454">1454</span>
<span id="1455">1455</span>
<span id="1456">1456</span>
<span id="1457">1457</span>
<span id="1458">1458</span>
<span id="1459">1459</span>
<span id="1460">1460</span>
<span id="1461">1461</span>
<span id="1462">1462</span>
<span id="1463">1463</span>
<span id="1464">1464</span>
<span id="1465">1465</span>
<span id="1466">1466</span>
<span id="1467">1467</span>
<span id="1468">1468</span>
<span id="1469">1469</span>
<span id="1470">1470</span>
<span id="1471">1471</span>
<span id="1472">1472</span>
<span id="1473">1473</span>
<span id="1474">1474</span>
<span id="1475">1475</span>
<span id="1476">1476</span>
<span id="1477">1477</span>
<span id="1478">1478</span>
<span id="1479">1479</span>
<span id="1480">1480</span>
<span id="1481">1481</span>
<span id="1482">1482</span>
<span id="1483">1483</span>
<span id="1484">1484</span>
<span id="1485">1485</span>
<span id="1486">1486</span>
<span id="1487">1487</span>
<span id="1488">1488</span>
<span id="1489">1489</span>
<span id="1490">1490</span>
<span id="1491">1491</span>
<span id="1492">1492</span>
<span id="1493">1493</span>
<span id="1494">1494</span>
<span id="1495">1495</span>
<span id="1496">1496</span>
<span id="1497">1497</span>
<span id="1498">1498</span>
<span id="1499">1499</span>
<span id="1500">1500</span>
<span id="1501">1501</span>
<span id="1502">1502</span>
<span id="1503">1503</span>
<span id="1504">1504</span>
<span id="1505">1505</span>
<span id="1506">1506</span>
<span id="1507">1507</span>
<span id="1508">1508</span>
<span id="1509">1509</span>
<span id="1510">1510</span>
<span id="1511">1511</span>
<span id="1512">1512</span>
<span id="1513">1513</span>
<span id="1514">1514</span>
<span id="1515">1515</span>
<span id="1516">1516</span>
<span id="1517">1517</span>
<span id="1518">1518</span>
<span id="1519">1519</span>
<span id="1520">1520</span>
<span id="1521">1521</span>
<span id="1522">1522</span>
<span id="1523">1523</span>
<span id="1524">1524</span>
<span id="1525">1525</span>
<span id="1526">1526</span>
<span id="1527">1527</span>
<span id="1528">1528</span>
<span id="1529">1529</span>
<span id="1530">1530</span>
<span id="1531">1531</span>
<span id="1532">1532</span>
<span id="1533">1533</span>
<span id="1534">1534</span>
<span id="1535">1535</span>
<span id="1536">1536</span>
<span id="1537">1537</span>
<span id="1538">1538</span>
<span id="1539">1539</span>
<span id="1540">1540</span>
<span id="1541">1541</span>
<span id="1542">1542</span>
<span id="1543">1543</span>
<span id="1544">1544</span>
<span id="1545">1545</span>
<span id="1546">1546</span>
<span id="1547">1547</span>
<span id="1548">1548</span>
<span id="1549">1549</span>
<span id="1550">1550</span>
<span id="1551">1551</span>
<span id="1552">1552</span>
<span id="1553">1553</span>
<span id="1554">1554</span>
<span id="1555">1555</span>
<span id="1556">1556</span>
<span id="1557">1557</span>
<span id="1558">1558</span>
<span id="1559">1559</span>
<span id="1560">1560</span>
<span id="1561">1561</span>
<span id="1562">1562</span>
<span id="1563">1563</span>
<span id="1564">1564</span>
<span id="1565">1565</span>
<span id="1566">1566</span>
<span id="1567">1567</span>
<span id="1568">1568</span>
<span id="1569">1569</span>
<span id="1570">1570</span>
<span id="1571">1571</span>
<span id="1572">1572</span>
<span id="1573">1573</span>
<span id="1574">1574</span>
<span id="1575">1575</span>
<span id="1576">1576</span>
<span id="1577">1577</span>
<span id="1578">1578</span>
<span id="1579">1579</span>
<span id="1580">1580</span>
<span id="1581">1581</span>
<span id="1582">1582</span>
<span id="1583">1583</span>
<span id="1584">1584</span>
<span id="1585">1585</span>
<span id="1586">1586</span>
<span id="1587">1587</span>
<span id="1588">1588</span>
<span id="1589">1589</span>
<span id="1590">1590</span>
<span id="1591">1591</span>
<span id="1592">1592</span>
<span id="1593">1593</span>
<span id="1594">1594</span>
<span id="1595">1595</span>
<span id="1596">1596</span>
<span id="1597">1597</span>
<span id="1598">1598</span>
<span id="1599">1599</span>
<span id="1600">1600</span>
<span id="1601">1601</span>
<span id="1602">1602</span>
<span id="1603">1603</span>
<span id="1604">1604</span>
<span id="1605">1605</span>
<span id="1606">1606</span>
<span id="1607">1607</span>
<span id="1608">1608</span>
<span id="1609">1609</span>
<span id="1610">1610</span>
<span id="1611">1611</span>
<span id="1612">1612</span>
<span id="1613">1613</span>
<span id="1614">1614</span>
<span id="1615">1615</span>
<span id="1616">1616</span>
<span id="1617">1617</span>
<span id="1618">1618</span>
<span id="1619">1619</span>
<span id="1620">1620</span>
<span id="1621">1621</span>
<span id="1622">1622</span>
<span id="1623">1623</span>
<span id="1624">1624</span>
<span id="1625">1625</span>
<span id="1626">1626</span>
<span id="1627">1627</span>
<span id="1628">1628</span>
<span id="1629">1629</span>
<span id="1630">1630</span>
<span id="1631">1631</span>
<span id="1632">1632</span>
<span id="1633">1633</span>
<span id="1634">1634</span>
<span id="1635">1635</span>
<span id="1636">1636</span>
<span id="1637">1637</span>
<span id="1638">1638</span>
<span id="1639">1639</span>
<span id="1640">1640</span>
<span id="1641">1641</span>
<span id="1642">1642</span>
<span id="1643">1643</span>
<span id="1644">1644</span>
<span id="1645">1645</span>
<span id="1646">1646</span>
<span id="1647">1647</span>
<span id="1648">1648</span>
<span id="1649">1649</span>
<span id="1650">1650</span>
<span id="1651">1651</span>
<span id="1652">1652</span>
<span id="1653">1653</span>
<span id="1654">1654</span>
<span id="1655">1655</span>
<span id="1656">1656</span>
<span id="1657">1657</span>
<span id="1658">1658</span>
<span id="1659">1659</span>
<span id="1660">1660</span>
<span id="1661">1661</span>
<span id="1662">1662</span>
<span id="1663">1663</span>
<span id="1664">1664</span>
<span id="1665">1665</span>
<span id="1666">1666</span>
<span id="1667">1667</span>
<span id="1668">1668</span>
<span id="1669">1669</span>
<span id="1670">1670</span>
<span id="1671">1671</span>
<span id="1672">1672</span>
<span id="1673">1673</span>
<span id="1674">1674</span>
<span id="1675">1675</span>
<span id="1676">1676</span>
<span id="1677">1677</span>
<span id="1678">1678</span>
<span id="1679">1679</span>
<span id="1680">1680</span>
<span id="1681">1681</span>
<span id="1682">1682</span>
<span id="1683">1683</span>
<span id="1684">1684</span>
<span id="1685">1685</span>
<span id="1686">1686</span>
<span id="1687">1687</span>
<span id="1688">1688</span>
<span id="1689">1689</span>
<span id="1690">1690</span>
<span id="1691">1691</span>
<span id="1692">1692</span>
<span id="1693">1693</span>
<span id="1694">1694</span>
<span id="1695">1695</span>
<span id="1696">1696</span>
<span id="1697">1697</span>
<span id="1698">1698</span>
<span id="1699">1699</span>
<span id="1700">1700</span>
<span id="1701">1701</span>
<span id="1702">1702</span>
<span id="1703">1703</span>
<span id="1704">1704</span>
<span id="1705">1705</span>
<span id="1706">1706</span>
<span id="1707">1707</span>
<span id="1708">1708</span>
<span id="1709">1709</span>
<span id="1710">1710</span>
<span id="1711">1711</span>
<span id="1712">1712</span>
<span id="1713">1713</span>
<span id="1714">1714</span>
<span id="1715">1715</span>
<span id="1716">1716</span>
<span id="1717">1717</span>
<span id="1718">1718</span>
<span id="1719">1719</span>
<span id="1720">1720</span>
<span id="1721">1721</span>
<span id="1722">1722</span>
<span id="1723">1723</span>
<span id="1724">1724</span>
<span id="1725">1725</span>
<span id="1726">1726</span>
<span id="1727">1727</span>
<span id="1728">1728</span>
<span id="1729">1729</span>
<span id="1730">1730</span>
<span id="1731">1731</span>
<span id="1732">1732</span>
<span id="1733">1733</span>
<span id="1734">1734</span>
<span id="1735">1735</span>
<span id="1736">1736</span>
<span id="1737">1737</span>
<span id="1738">1738</span>
<span id="1739">1739</span>
<span id="1740">1740</span>
<span id="1741">1741</span>
<span id="1742">1742</span>
<span id="1743">1743</span>
<span id="1744">1744</span>
<span id="1745">1745</span>
<span id="1746">1746</span>
<span id="1747">1747</span>
<span id="1748">1748</span>
<span id="1749">1749</span>
<span id="1750">1750</span>
<span id="1751">1751</span>
<span id="1752">1752</span>
<span id="1753">1753</span>
<span id="1754">1754</span>
<span id="1755">1755</span>
<span id="1756">1756</span>
<span id="1757">1757</span>
<span id="1758">1758</span>
<span id="1759">1759</span>
<span id="1760">1760</span>
<span id="1761">1761</span>
<span id="1762">1762</span>
<span id="1763">1763</span>
<span id="1764">1764</span>
<span id="1765">1765</span>
<span id="1766">1766</span>
<span id="1767">1767</span>
<span id="1768">1768</span>
<span id="1769">1769</span>
<span id="1770">1770</span>
<span id="1771">1771</span>
<span id="1772">1772</span>
<span id="1773">1773</span>
<span id="1774">1774</span>
<span id="1775">1775</span>
<span id="1776">1776</span>
<span id="1777">1777</span>
<span id="1778">1778</span>
<span id="1779">1779</span>
<span id="1780">1780</span>
<span id="1781">1781</span>
<span id="1782">1782</span>
<span id="1783">1783</span>
<span id="1784">1784</span>
<span id="1785">1785</span>
<span id="1786">1786</span>
<span id="1787">1787</span>
<span id="1788">1788</span>
<span id="1789">1789</span>
<span id="1790">1790</span>
<span id="1791">1791</span>
<span id="1792">1792</span>
<span id="1793">1793</span>
<span id="1794">1794</span>
<span id="1795">1795</span>
<span id="1796">1796</span>
<span id="1797">1797</span>
<span id="1798">1798</span>
<span id="1799">1799</span>
<span id="1800">1800</span>
<span id="1801">1801</span>
<span id="1802">1802</span>
<span id="1803">1803</span>
<span id="1804">1804</span>
<span id="1805">1805</span>
<span id="1806">1806</span>
<span id="1807">1807</span>
<span id="1808">1808</span>
<span id="1809">1809</span>
<span id="1810">1810</span>
<span id="1811">1811</span>
<span id="1812">1812</span>
<span id="1813">1813</span>
<span id="1814">1814</span>
<span id="1815">1815</span>
<span id="1816">1816</span>
<span id="1817">1817</span>
<span id="1818">1818</span>
<span id="1819">1819</span>
<span id="1820">1820</span>
<span id="1821">1821</span>
<span id="1822">1822</span>
<span id="1823">1823</span>
<span id="1824">1824</span>
<span id="1825">1825</span>
<span id="1826">1826</span>
<span id="1827">1827</span>
<span id="1828">1828</span>
<span id="1829">1829</span>
<span id="1830">1830</span>
<span id="1831">1831</span>
<span id="1832">1832</span>
<span id="1833">1833</span>
<span id="1834">1834</span>
<span id="1835">1835</span>
<span id="1836">1836</span>
<span id="1837">1837</span>
<span id="1838">1838</span>
<span id="1839">1839</span>
<span id="1840">1840</span>
<span id="1841">1841</span>
<span id="1842">1842</span>
<span id="1843">1843</span>
<span id="1844">1844</span>
<span id="1845">1845</span>
<span id="1846">1846</span>
<span id="1847">1847</span>
<span id="1848">1848</span>
<span id="1849">1849</span>
<span id="1850">1850</span>
<span id="1851">1851</span>
<span id="1852">1852</span>
<span id="1853">1853</span>
<span id="1854">1854</span>
<span id="1855">1855</span>
<span id="1856">1856</span>
<span id="1857">1857</span>
<span id="1858">1858</span>
<span id="1859">1859</span>
<span id="1860">1860</span>
<span id="1861">1861</span>
<span id="1862">1862</span>
<span id="1863">1863</span>
<span id="1864">1864</span>
<span id="1865">1865</span>
<span id="1866">1866</span>
<span id="1867">1867</span>
<span id="1868">1868</span>
<span id="1869">1869</span>
<span id="1870">1870</span>
<span id="1871">1871</span>
<span id="1872">1872</span>
<span id="1873">1873</span>
<span id="1874">1874</span>
<span id="1875">1875</span>
<span id="1876">1876</span>
<span id="1877">1877</span>
<span id="1878">1878</span>
<span id="1879">1879</span>
<span id="1880">1880</span>
<span id="1881">1881</span>
<span id="1882">1882</span>
<span id="1883">1883</span>
<span id="1884">1884</span>
<span id="1885">1885</span>
<span id="1886">1886</span>
<span id="1887">1887</span>
<span id="1888">1888</span>
<span id="1889">1889</span>
<span id="1890">1890</span>
<span id="1891">1891</span>
<span id="1892">1892</span>
<span id="1893">1893</span>
<span id="1894">1894</span>
<span id="1895">1895</span>
<span id="1896">1896</span>
<span id="1897">1897</span>
<span id="1898">1898</span>
<span id="1899">1899</span>
<span id="1900">1900</span>
<span id="1901">1901</span>
<span id="1902">1902</span>
<span id="1903">1903</span>
<span id="1904">1904</span>
<span id="1905">1905</span>
<span id="1906">1906</span>
<span id="1907">1907</span>
<span id="1908">1908</span>
<span id="1909">1909</span>
<span id="1910">1910</span>
<span id="1911">1911</span>
<span id="1912">1912</span>
</pre><pre class="rust"><code><span class="kw">use</span> <span class="ident"><span class="kw">super</span>::core</span>::{
    <span class="ident">af_array</span>, <span class="ident">dim_t</span>, <span class="ident">AfError</span>, <span class="ident">Array</span>, <span class="ident">BorderType</span>, <span class="ident">CannyThresholdType</span>, <span class="ident">ColorSpace</span>, <span class="ident">ConfidenceCCInput</span>,
    <span class="ident">Connectivity</span>, <span class="ident">DeconvInput</span>, <span class="ident">DiffusionEq</span>, <span class="ident">EdgeComputable</span>, <span class="ident">FloatingPoint</span>, <span class="ident">FluxFn</span>,
    <span class="ident">GrayRGBConvertible</span>, <span class="ident">HasAfEnum</span>, <span class="ident">ImageFilterType</span>, <span class="ident">ImageNativeType</span>, <span class="ident">InterpType</span>, <span class="ident">InverseDeconvAlgo</span>,
    <span class="ident">IterativeDeconvAlgo</span>, <span class="ident">MomentType</span>, <span class="ident">MomentsComputable</span>, <span class="ident">RealFloating</span>, <span class="ident">RealNumber</span>, <span class="ident">YCCStd</span>,
    <span class="ident">HANDLE_ERROR</span>,
};

<span class="kw">use</span> <span class="ident">libc</span>::{<span class="ident">c_char</span>, <span class="ident">c_double</span>, <span class="ident">c_float</span>, <span class="ident">c_int</span>, <span class="ident">c_uint</span>};
<span class="kw">use</span> <span class="ident">std::ffi::CString</span>;

<span class="comment">// unused functions from image.h header</span>
<span class="comment">// TODO add later when requested</span>
<span class="comment">// af_load_image_memory</span>
<span class="comment">// af_save_image_memory</span>
<span class="comment">// af_delete_image_memory</span>

<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
    <span class="kw">fn</span> <span class="ident">af_cast</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">arr</span>: <span class="ident">af_array</span>, <span class="ident">aftype</span>: <span class="ident">c_uint</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_gradient</span>(<span class="ident">dx</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">dy</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">arr</span>: <span class="ident">af_array</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_load_image</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">filename</span>: <span class="kw-2">*const</span> <span class="ident">c_char</span>, <span class="ident">iscolor</span>: <span class="ident">bool</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_save_image</span>(<span class="ident">filename</span>: <span class="kw-2">*const</span> <span class="ident">c_char</span>, <span class="ident">input</span>: <span class="ident">af_array</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_load_image_native</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">filename</span>: <span class="kw-2">*const</span> <span class="ident">c_char</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_save_image_native</span>(<span class="ident">filename</span>: <span class="kw-2">*const</span> <span class="ident">c_char</span>, <span class="ident">input</span>: <span class="ident">af_array</span>) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_resize</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">odim0</span>: <span class="ident">dim_t</span>,
        <span class="ident">odim1</span>: <span class="ident">dim_t</span>,
        <span class="ident">method</span>: <span class="ident">c_uint</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_transform</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">trans</span>: <span class="ident">af_array</span>,
        <span class="ident">odim0</span>: <span class="ident">dim_t</span>,
        <span class="ident">odim1</span>: <span class="ident">dim_t</span>,
        <span class="ident">method</span>: <span class="ident">c_uint</span>,
        <span class="ident">is_inverse</span>: <span class="ident">bool</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_rotate</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">theta</span>: <span class="ident">c_float</span>,
        <span class="ident">crop</span>: <span class="ident">bool</span>,
        <span class="ident">method</span>: <span class="ident">c_uint</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_translate</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">trans0</span>: <span class="ident">c_float</span>,
        <span class="ident">trans1</span>: <span class="ident">c_float</span>,
        <span class="ident">odim0</span>: <span class="ident">dim_t</span>,
        <span class="ident">odim1</span>: <span class="ident">dim_t</span>,
        <span class="ident">method</span>: <span class="ident">c_uint</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_scale</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">scale0</span>: <span class="ident">c_float</span>,
        <span class="ident">scale1</span>: <span class="ident">c_float</span>,
        <span class="ident">odim0</span>: <span class="ident">dim_t</span>,
        <span class="ident">odim1</span>: <span class="ident">dim_t</span>,
        <span class="ident">method</span>: <span class="ident">c_uint</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_skew</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">skew0</span>: <span class="ident">c_float</span>,
        <span class="ident">skew1</span>: <span class="ident">c_float</span>,
        <span class="ident">odim0</span>: <span class="ident">dim_t</span>,
        <span class="ident">odim1</span>: <span class="ident">dim_t</span>,
        <span class="ident">method</span>: <span class="ident">c_uint</span>,
        <span class="ident">is_inverse</span>: <span class="ident">bool</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_histogram</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">nbins</span>: <span class="ident">c_uint</span>,
        <span class="ident">minval</span>: <span class="ident">c_double</span>,
        <span class="ident">maxval</span>: <span class="ident">c_double</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_dilate</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>: <span class="ident">af_array</span>, <span class="ident">mask</span>: <span class="ident">af_array</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_dilate3</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>: <span class="ident">af_array</span>, <span class="ident">mask</span>: <span class="ident">af_array</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_erode</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>: <span class="ident">af_array</span>, <span class="ident">mask</span>: <span class="ident">af_array</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_erode3</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>: <span class="ident">af_array</span>, <span class="ident">mask</span>: <span class="ident">af_array</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_regions</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>: <span class="ident">af_array</span>, <span class="ident">conn</span>: <span class="ident">c_uint</span>, <span class="ident">aftype</span>: <span class="ident">c_uint</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_sobel_operator</span>(<span class="ident">dx</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">dy</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">i</span>: <span class="ident">af_array</span>, <span class="ident">ksize</span>: <span class="ident">c_uint</span>)
        -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_rgb2gray</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">r</span>: <span class="ident">c_float</span>,
        <span class="ident">g</span>: <span class="ident">c_float</span>,
        <span class="ident">b</span>: <span class="ident">c_float</span>,
    ) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_gray2rgb</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">r</span>: <span class="ident">c_float</span>,
        <span class="ident">g</span>: <span class="ident">c_float</span>,
        <span class="ident">b</span>: <span class="ident">c_float</span>,
    ) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_hist_equal</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>: <span class="ident">af_array</span>, <span class="ident">hist</span>: <span class="ident">af_array</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_hsv2rgb</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>: <span class="ident">af_array</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_rgb2hsv</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>: <span class="ident">af_array</span>) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_bilateral</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">sp_sig</span>: <span class="ident">c_float</span>,
        <span class="ident">ch_sig</span>: <span class="ident">c_float</span>,
        <span class="ident">iscolor</span>: <span class="ident">bool</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_mean_shift</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">sp_sig</span>: <span class="ident">c_float</span>,
        <span class="ident">ch_sig</span>: <span class="ident">c_float</span>,
        <span class="ident">iter</span>: <span class="ident">c_uint</span>,
        <span class="ident">iscolor</span>: <span class="ident">bool</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_medfilt</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">wlen</span>: <span class="ident">dim_t</span>,
        <span class="ident">wwid</span>: <span class="ident">dim_t</span>,
        <span class="ident">etype</span>: <span class="ident">c_uint</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_medfilt1</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>: <span class="ident">af_array</span>, <span class="ident">wlen</span>: <span class="ident">dim_t</span>, <span class="ident">etype</span>: <span class="ident">c_uint</span>) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_minfilt</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">wlen</span>: <span class="ident">dim_t</span>,
        <span class="ident">wwid</span>: <span class="ident">dim_t</span>,
        <span class="ident">etype</span>: <span class="ident">c_uint</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_maxfilt</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">wlen</span>: <span class="ident">dim_t</span>,
        <span class="ident">wwid</span>: <span class="ident">dim_t</span>,
        <span class="ident">etype</span>: <span class="ident">c_uint</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_gaussian_kernel</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">rows</span>: <span class="ident">c_int</span>,
        <span class="ident">cols</span>: <span class="ident">c_int</span>,
        <span class="ident">sigma_r</span>: <span class="ident">c_double</span>,
        <span class="ident">sigma_c</span>: <span class="ident">c_double</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_color_space</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">tospace</span>: <span class="ident">c_uint</span>,
        <span class="ident">fromspace</span>: <span class="ident">c_uint</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_unwrap</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">wx</span>: <span class="ident">dim_t</span>,
        <span class="ident">wy</span>: <span class="ident">dim_t</span>,
        <span class="ident">sx</span>: <span class="ident">dim_t</span>,
        <span class="ident">sy</span>: <span class="ident">dim_t</span>,
        <span class="ident">px</span>: <span class="ident">dim_t</span>,
        <span class="ident">py</span>: <span class="ident">dim_t</span>,
        <span class="ident">is_column</span>: <span class="ident">bool</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_wrap</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">ox</span>: <span class="ident">dim_t</span>,
        <span class="ident">oy</span>: <span class="ident">dim_t</span>,
        <span class="ident">wx</span>: <span class="ident">dim_t</span>,
        <span class="ident">wy</span>: <span class="ident">dim_t</span>,
        <span class="ident">sx</span>: <span class="ident">dim_t</span>,
        <span class="ident">sy</span>: <span class="ident">dim_t</span>,
        <span class="ident">px</span>: <span class="ident">dim_t</span>,
        <span class="ident">py</span>: <span class="ident">dim_t</span>,
        <span class="ident">is_column</span>: <span class="ident">bool</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_sat</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>: <span class="ident">af_array</span>) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_ycbcr2rgb</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>: <span class="ident">af_array</span>, <span class="ident">stnd</span>: <span class="ident">c_uint</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_rgb2ycbcr</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>: <span class="ident">af_array</span>, <span class="ident">stnd</span>: <span class="ident">c_uint</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_is_image_io_available</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">bool</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_transform_coordinates</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">tf</span>: <span class="ident">af_array</span>,
        <span class="ident">d0</span>: <span class="ident">c_float</span>,
        <span class="ident">d1</span>: <span class="ident">c_float</span>,
    ) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_moments</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>: <span class="ident">af_array</span>, <span class="ident">moment</span>: <span class="ident">c_uint</span>) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_moments_all</span>(<span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">c_double</span>, <span class="ident">input</span>: <span class="ident">af_array</span>, <span class="ident">moment</span>: <span class="ident">c_uint</span>) -&gt; <span class="ident">c_int</span>;

    <span class="kw">fn</span> <span class="ident">af_canny</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">thres_type</span>: <span class="ident">c_int</span>,
        <span class="ident">low</span>: <span class="ident">c_float</span>,
        <span class="ident">high</span>: <span class="ident">c_float</span>,
        <span class="ident">swindow</span>: <span class="ident">c_uint</span>,
        <span class="ident">is_fast</span>: <span class="ident">bool</span>,
    ) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_anisotropic_diffusion</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">dt</span>: <span class="ident">c_float</span>,
        <span class="ident">K</span>: <span class="ident">c_float</span>,
        <span class="ident">iters</span>: <span class="ident">c_uint</span>,
        <span class="ident">fftype</span>: <span class="ident">c_uint</span>,
        <span class="ident">diff_kind</span>: <span class="ident">c_uint</span>,
    ) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_confidence_cc</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">seedx</span>: <span class="ident">af_array</span>,
        <span class="ident">seedy</span>: <span class="ident">af_array</span>,
        <span class="ident">radius</span>: <span class="ident">c_uint</span>,
        <span class="ident">multiplier</span>: <span class="ident">c_uint</span>,
        <span class="ident">iterations</span>: <span class="ident">c_int</span>,
        <span class="ident">seg_val</span>: <span class="ident">c_double</span>,
    ) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_iterative_deconv</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">ker</span>: <span class="ident">af_array</span>,
        <span class="ident">iterations</span>: <span class="ident">c_uint</span>,
        <span class="ident">rfactor</span>: <span class="ident">c_float</span>,
        <span class="ident">algo</span>: <span class="ident">c_uint</span>,
    ) -&gt; <span class="ident">c_int</span>;
    <span class="kw">fn</span> <span class="ident">af_inverse_deconv</span>(
        <span class="ident">out</span>: <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
        <span class="ident">input</span>: <span class="ident">af_array</span>,
        <span class="ident">ker</span>: <span class="ident">af_array</span>,
        <span class="ident">gamma</span>: <span class="ident">c_float</span>,
        <span class="ident">algo</span>: <span class="ident">c_uint</span>,
    ) -&gt; <span class="ident">c_int</span>;
}

<span class="doccomment">/// Calculate the gradients</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The gradients along the first and second dimensions are calculated simultaneously.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input Array</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// A tuple of Arrays.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The first Array is `dx` which is the gradient along the 1st dimension.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The second Array is `dy` which is the gradient along the 2nd dimension.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">gradient</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>) -&gt; (<span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>)
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">FloatingPoint</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dx</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dy</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_gradient</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">dx</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="kw-2">&amp;mut</span> <span class="ident">dy</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        (<span class="ident">dx</span>.<span class="ident">into</span>(), <span class="ident">dy</span>.<span class="ident">into</span>())
    }
}

<span class="doccomment">/// Load Image into Array</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Only, Images with 8/16/32 bits per channel can be loaded using this function.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `filename` is aboslute path of the image to be loaded.</span>
<span class="doccomment">/// - `is_color` indicates if the image file at given path is color or gray scale.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Arrays</span>
<span class="doccomment">///</span>
<span class="doccomment">/// An Array with pixel values loaded from the image</span>
<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::match_wild_err_arm</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">load_image</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">filename</span>: <span class="ident">String</span>, <span class="ident">is_color</span>: <span class="ident">bool</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">RealNumber</span>,
{
    <span class="kw">let</span> <span class="ident">cstr_param</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">CString::new</span>(<span class="ident">filename</span>) {
        <span class="prelude-val">Ok</span>(<span class="ident">cstr</span>) =&gt; <span class="ident">cstr</span>,
        <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">panic!</span>(<span class="string">&quot;CString creation from input filename failed&quot;</span>),
    };
    <span class="kw">let</span> <span class="ident">trgt_type</span> <span class="op">=</span> <span class="ident">T::get_af_dtype</span>();
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err1</span> <span class="op">=</span> <span class="ident">af_load_image</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">cstr_param</span>.<span class="ident">as_ptr</span>(), <span class="ident">is_color</span>);
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err1</span>));

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">img</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err2</span> <span class="op">=</span> <span class="ident">af_cast</span>(<span class="kw-2">&amp;mut</span> <span class="ident">img</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">temp</span>, <span class="ident">trgt_type</span> <span class="kw">as</span> <span class="ident">c_uint</span>);
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err2</span>));

        <span class="ident">img</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Load Image into Array in it&#39;s native type</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This load image function allows you to load images as U8, U16 or F32</span>
<span class="doccomment">/// depending on the type of input image as shown by the table below.</span>
<span class="doccomment">///</span>
<span class="doccomment">///  Bits per Color (Gray/RGB/RGBA Bits Per Pixel) | Array Type  | Range</span>
<span class="doccomment">/// -----------------------------------------------|-------------|---------------</span>
<span class="doccomment">///   8 ( 8/24/32  BPP)                            | u8          | 0 - 255</span>
<span class="doccomment">///  16 (16/48/64  BPP)                            | u16         | 0 - 65535</span>
<span class="doccomment">///  32 (32/96/128 BPP)                            | f32         | 0 - 1</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `filename` is name of file to be loaded</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Arrays</span>
<span class="doccomment">///</span>
<span class="doccomment">/// An Array with pixel values loaded from the image</span>
<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::match_wild_err_arm</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">load_image_native</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">filename</span>: <span class="ident">String</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">ImageNativeType</span>,
{
    <span class="kw">let</span> <span class="ident">cstr_param</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">CString::new</span>(<span class="ident">filename</span>) {
        <span class="prelude-val">Ok</span>(<span class="ident">cstr</span>) =&gt; <span class="ident">cstr</span>,
        <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">panic!</span>(<span class="string">&quot;CString creation from input filename failed&quot;</span>),
    };
    <span class="kw">let</span> <span class="ident">trgt_type</span> <span class="op">=</span> <span class="ident">T::get_af_dtype</span>();
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err1</span> <span class="op">=</span> <span class="ident">af_load_image_native</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">cstr_param</span>.<span class="ident">as_ptr</span>());
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err1</span>));

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">img</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err2</span> <span class="op">=</span> <span class="ident">af_cast</span>(<span class="kw-2">&amp;mut</span> <span class="ident">img</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">temp</span>, <span class="ident">trgt_type</span> <span class="kw">as</span> <span class="ident">c_uint</span>);
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err2</span>));

        <span class="ident">img</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Save an Array to an image file</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `filename` is the abolute path(includes filename) at which input Array is going to be saved</span>
<span class="doccomment">/// - `input` is the Array to be stored into the image file</span>
<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::match_wild_err_arm</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">save_image</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">filename</span>: <span class="ident">String</span>, <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>)
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">RealNumber</span>,
{
    <span class="kw">let</span> <span class="ident">cstr_param</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">CString::new</span>(<span class="ident">filename</span>) {
        <span class="prelude-val">Ok</span>(<span class="ident">cstr</span>) =&gt; <span class="ident">cstr</span>,
        <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">panic!</span>(<span class="string">&quot;CString creation from input filename failed&quot;</span>),
    };
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_save_image</span>(<span class="ident">cstr_param</span>.<span class="ident">as_ptr</span>(), <span class="ident">input</span>.<span class="ident">get</span>());
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
    }
}

<span class="doccomment">/// Save an Array without modifications to an image file</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This function only accepts U8, U16, F32 arrays. These arrays are saved to images without any modifications. You must also note that note all image type support 16 or 32 bit images. The best options for 16 bit images are PNG, PPM and TIFF. The best option for 32 bit images is TIFF. These allow lossless storage.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The images stored have the following properties:</span>
<span class="doccomment">///</span>
<span class="doccomment">///  Array Type  | Bits per Color (Gray/RGB/RGBA Bits Per Pixel) | Range</span>
<span class="doccomment">/// -------------|-----------------------------------------------|---------------</span>
<span class="doccomment">///  U8          |  8 ( 8/24/32  BPP)                            | 0 - 255</span>
<span class="doccomment">///  U16         | 16 (16/48/64  BPP)                            | 0 - 65535</span>
<span class="doccomment">///  F32         | 32 (32/96/128 BPP)                            | 0 - 1</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `filename` is name of file to be saved</span>
<span class="doccomment">/// - `input` is the Array to be saved. Should be U8 for saving 8-bit image, U16 for 16-bit image, and F32 for 32-bit image.</span>
<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::match_wild_err_arm</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">save_image_native</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">filename</span>: <span class="ident">String</span>, <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>)
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">ImageNativeType</span>,
{
    <span class="kw">let</span> <span class="ident">cstr_param</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">CString::new</span>(<span class="ident">filename</span>) {
        <span class="prelude-val">Ok</span>(<span class="ident">cstr</span>) =&gt; <span class="ident">cstr</span>,
        <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">panic!</span>(<span class="string">&quot;CString creation from input filename failed&quot;</span>),
    };
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_save_image_native</span>(<span class="ident">cstr_param</span>.<span class="ident">as_ptr</span>(), <span class="ident">input</span>.<span class="ident">get</span>());
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
    }
}

<span class="doccomment">/// Resize an Image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Resizing an input image can be done using either NEAREST or BILINEAR interpolations.</span>
<span class="doccomment">/// Nearest interpolation will pick the nearest value to the location, whereas bilinear</span>
<span class="doccomment">/// interpolation will do a weighted interpolation for calculate the new size.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This function does not differentiate between images and data. As long as the array is defined</span>
<span class="doccomment">/// and the output dimensions are not 0, it will resize any type or size of array.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the image to be resized</span>
<span class="doccomment">/// - `odim0` is the output height</span>
<span class="doccomment">/// - `odim1` is the output width</span>
<span class="doccomment">/// - `method` indicates which interpolation method to use for resizing. It uses enum</span>
<span class="doccomment">/// [InterpType](./enum.InterpType.html) to identify the interpolation method.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Resized Array</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">resize</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">HasAfEnum</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">odim0</span>: <span class="ident">i64</span>,
    <span class="ident">odim1</span>: <span class="ident">i64</span>,
    <span class="ident">method</span>: <span class="ident">InterpType</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_resize</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">odim0</span> <span class="kw">as</span> <span class="ident">dim_t</span>,
            <span class="ident">odim1</span> <span class="kw">as</span> <span class="ident">dim_t</span>,
            <span class="ident">method</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Transform(Affine) an Image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The transform function uses an affine transform matrix to tranform an input image into a new</span>
<span class="doccomment">/// one. The transform matrix tf is a 3x2 matrix of type float. The matrix operation is applied to each</span>
<span class="doccomment">/// location (x, y) that is then transformed to (x&#39;, y&#39;) of the new array. Hence the transformation</span>
<span class="doccomment">/// is an element-wise operation.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The operation is as below: tf = [r00 r10 r01 r11 t0 t1]</span>
<span class="doccomment">///</span>
<span class="doccomment">/// x&#39; = x * r00 + y * r01 + t0; y&#39; = x * r10 + y * r11 + t1;</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Interpolation types of NEAREST, LINEAR, BILINEAR and CUBIC are allowed. Affine transforms can be used for various purposes. [translate](./fn.translate.html), [scale](./fn.scale.html) and [skew](./fn.skew.html) are</span>
<span class="doccomment">/// specializations of the transform function.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This function can also handle batch operations.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the image to be resized</span>
<span class="doccomment">/// - `trans` is the transformation matrix to be used for image transformation</span>
<span class="doccomment">/// - `odim0` is the output height</span>
<span class="doccomment">/// - `odim1` is the output width</span>
<span class="doccomment">/// - `method` indicates which interpolation method to use for resizing. It uses enum</span>
<span class="doccomment">/// [InterpType](./enum.InterpType.html) to identify the interpolation method.</span>
<span class="doccomment">/// - `is_inverse` indicates if to apply inverse/forward transform</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Transformed Array</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">transform</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">HasAfEnum</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">trans</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span>,
    <span class="ident">odim0</span>: <span class="ident">i64</span>,
    <span class="ident">odim1</span>: <span class="ident">i64</span>,
    <span class="ident">method</span>: <span class="ident">InterpType</span>,
    <span class="ident">is_inverse</span>: <span class="ident">bool</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_transform</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">trans</span>.<span class="ident">get</span>(),
            <span class="ident">odim0</span> <span class="kw">as</span> <span class="ident">dim_t</span>,
            <span class="ident">odim1</span> <span class="kw">as</span> <span class="ident">dim_t</span>,
            <span class="ident">method</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
            <span class="ident">is_inverse</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Rotate an Image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Rotating an input image can be done using either NEAREST or BILINEAR interpolations.</span>
<span class="doccomment">/// Nearest interpolation will pick the nearest value to the location, whereas bilinear</span>
<span class="doccomment">/// interpolation will do a weighted interpolation for calculate the new size.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This function does not differentiate between images and data. As long as the array is defined,</span>
<span class="doccomment">/// it will rotate any type or size of array.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The crop option allows you to choose whether to resize the image. If crop is set to false, ie.</span>
<span class="doccomment">/// the entire rotated image will be a part of the array and the new array size will be greater</span>
<span class="doccomment">/// than or equal to the input array size. If crop is set to true, then the new array size is same</span>
<span class="doccomment">/// as the input array size and the data that falls outside the boundaries of the array is</span>
<span class="doccomment">/// discarded.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Any location of the rotated array that does not map to a location of the input array is set to</span>
<span class="doccomment">/// 0.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image</span>
<span class="doccomment">/// - `theta` is the amount of angle (in radians) image should be rotated</span>
<span class="doccomment">/// - `crop` indicates if the rotated image has to be cropped to original size</span>
<span class="doccomment">/// - `method` indicates which interpolation method to use for rotating the image. It uses enum</span>
<span class="doccomment">/// [InterpType](./enum.InterpType.html) to identify the interpolation method.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Rotated Array</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">rotate</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">HasAfEnum</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">theta</span>: <span class="ident">f64</span>,
    <span class="ident">crop</span>: <span class="ident">bool</span>,
    <span class="ident">method</span>: <span class="ident">InterpType</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_rotate</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">theta</span> <span class="kw">as</span> <span class="ident">c_float</span>,
            <span class="ident">crop</span>,
            <span class="ident">method</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Translate an Image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Translating an image is moving it along 1st and 2nd dimensions by trans0 and trans1. Positive</span>
<span class="doccomment">/// values of these will move the data towards negative x and negative y whereas negative values of</span>
<span class="doccomment">/// these will move the positive right and positive down. See the example below for more.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// To specify an output dimension, use the odim0 and odim1 for dim0 and dim1 respectively. The</span>
<span class="doccomment">/// size of 2rd and 3rd dimension is same as input. If odim0 and odim1 and not defined, then the</span>
<span class="doccomment">/// output dimensions are same as the input dimensions and the data out of bounds will be</span>
<span class="doccomment">/// discarded.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// All new values that do not map to a location of the input array are set to 0.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Translate is a special case of the [transform](./fn.transform.html) function.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is input image</span>
<span class="doccomment">/// - `trans0` is amount by which the first dimension is translated</span>
<span class="doccomment">/// - `trans1` is amount by which the second dimension is translated</span>
<span class="doccomment">/// - `odim0` is the first output dimension</span>
<span class="doccomment">/// - `odim1` is the second output dimension</span>
<span class="doccomment">/// - `method` is the interpolation type (Nearest by default)</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Translated Image(Array).</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">translate</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">HasAfEnum</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">trans0</span>: <span class="ident">f32</span>,
    <span class="ident">trans1</span>: <span class="ident">f32</span>,
    <span class="ident">odim0</span>: <span class="ident">i64</span>,
    <span class="ident">odim1</span>: <span class="ident">i64</span>,
    <span class="ident">method</span>: <span class="ident">InterpType</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_translate</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">trans0</span>,
            <span class="ident">trans1</span>,
            <span class="ident">odim0</span> <span class="kw">as</span> <span class="ident">dim_t</span>,
            <span class="ident">odim1</span> <span class="kw">as</span> <span class="ident">dim_t</span>,
            <span class="ident">method</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Scale an Image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Scale is the same functionality as [resize](./fn.resize.html) except that the scale function uses the transform kernels. The other difference is that scale does not set boundary values to be the boundary of the input array. Instead these are set to 0.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Scale is a special case of the [transform](./fn.transform.html) function.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is input image</span>
<span class="doccomment">/// - `trans0` is amount by which the first dimension is translated</span>
<span class="doccomment">/// - `trans1` is amount by which the second dimension is translated</span>
<span class="doccomment">/// - `odim0` is the first output dimension</span>
<span class="doccomment">/// - `odim1` is the second output dimension</span>
<span class="doccomment">/// - `method` is the interpolation type (Nearest by default)</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Translated Image(Array).</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">scale</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">HasAfEnum</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">scale0</span>: <span class="ident">f32</span>,
    <span class="ident">scale1</span>: <span class="ident">f32</span>,
    <span class="ident">odim0</span>: <span class="ident">i64</span>,
    <span class="ident">odim1</span>: <span class="ident">i64</span>,
    <span class="ident">method</span>: <span class="ident">InterpType</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_scale</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">scale0</span>,
            <span class="ident">scale1</span>,
            <span class="ident">odim0</span> <span class="kw">as</span> <span class="ident">dim_t</span>,
            <span class="ident">odim1</span> <span class="kw">as</span> <span class="ident">dim_t</span>,
            <span class="ident">method</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Skew an image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Skew function skews the input array along dim0 by skew0 and along dim1 by skew1. The skew</span>
<span class="doccomment">/// areguments are in radians. Skewing the data means the data remains parallel along 1 dimensions</span>
<span class="doccomment">/// but the other dimensions gets moved along based on the angle. If both skew0 and skew1 are</span>
<span class="doccomment">/// specified, then the data will be skewed along both directions. Explicit output dimensions</span>
<span class="doccomment">/// can be specified using odim0 and odim1. All new values that do not map to a location of the input array are set to 0.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Skew is a special case of the [transform](./fn.transform.html) function.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the image to be skewed</span>
<span class="doccomment">/// - `skew0` is the factor by which data is skewed along first dimension</span>
<span class="doccomment">/// - `skew1` is the factor by which data is skewed along second dimension</span>
<span class="doccomment">/// - `odim0` is the output length along first dimension</span>
<span class="doccomment">/// - `odim1` is the output length along second dimension</span>
<span class="doccomment">/// - `method` indicates which interpolation method to use for rotating the image. It uses enum</span>
<span class="doccomment">/// [InterpType](./enum.InterpType.html) to identify the interpolation method.</span>
<span class="doccomment">/// - `is_inverse` indicates if to apply inverse/forward transform</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Skewed Image</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">skew</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">HasAfEnum</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">skew0</span>: <span class="ident">f32</span>,
    <span class="ident">skew1</span>: <span class="ident">f32</span>,
    <span class="ident">odim0</span>: <span class="ident">i64</span>,
    <span class="ident">odim1</span>: <span class="ident">i64</span>,
    <span class="ident">method</span>: <span class="ident">InterpType</span>,
    <span class="ident">is_inverse</span>: <span class="ident">bool</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_skew</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">skew0</span>,
            <span class="ident">skew1</span>,
            <span class="ident">odim0</span> <span class="kw">as</span> <span class="ident">dim_t</span>,
            <span class="ident">odim1</span> <span class="kw">as</span> <span class="ident">dim_t</span>,
            <span class="ident">method</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
            <span class="ident">is_inverse</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Compute Histogram of an Array</span>
<span class="doccomment">///</span>
<span class="doccomment">/// A histogram is a representation of the distribution of given data. This representation is</span>
<span class="doccomment">/// essentially a graph consisting of the data range or domain on one axis and frequency of</span>
<span class="doccomment">/// occurence on the other axis. All the data in the domain is counted in the appropriate bin. The</span>
<span class="doccomment">/// total number of elements belonging to each bin is known as the bin&#39;s frequency.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The regular histogram function creates bins of equal size between the minimum and maximum of</span>
<span class="doccomment">/// the input data (min and max are calculated internally). The histogram min-max function takes</span>
<span class="doccomment">/// input parameters minimum and maximum, and divides the bins into equal sizes within the range</span>
<span class="doccomment">/// specified by min and max parameters. All values less than min in the data range are placed in</span>
<span class="doccomment">/// the first (min) bin and all values greater than max will be placed in the last (max) bin.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the Array whose histogram has to be computed</span>
<span class="doccomment">/// - `nbins` is the number bins the input data has to be categorized into.</span>
<span class="doccomment">/// - `minval` is the minimum value of bin ordering</span>
<span class="doccomment">/// - `maxval` is the maximum value of bin ordering</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Histogram of input Array</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">histogram</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">nbins</span>: <span class="ident">u32</span>, <span class="ident">minval</span>: <span class="ident">f64</span>, <span class="ident">maxval</span>: <span class="ident">f64</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">RealNumber</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_histogram</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">nbins</span>,
            <span class="ident">minval</span>,
            <span class="ident">maxval</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Dilate an Image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The dilation function takes two pieces of data as inputs. The first is the input image to be</span>
<span class="doccomment">/// morphed, and the second is the mask indicating the neighborhood around each pixel to match.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// In dilation, for each pixel, the mask is centered at the pixel. If the center pixel of the mask</span>
<span class="doccomment">/// matches the corresponding pixel on the image, then the mask is accepted. If the center pixels</span>
<span class="doccomment">/// do not matches, then the mask is ignored and no changes are made.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// For further reference, see [here](https://en.wikipedia.org/wiki/Dilation_(morphology)).</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image</span>
<span class="doccomment">/// - `mask` is the morphological operation mask</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Dilated Image(Array)</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">dilate</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">mask</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">ImageFilterType</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_dilate</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>.<span class="ident">get</span>(), <span class="ident">mask</span>.<span class="ident">get</span>());
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Erode an Image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The erosion function is a morphological transformation on an image that requires two inputs.</span>
<span class="doccomment">/// The first is the image to be morphed, and the second is the mask indicating neighborhood that</span>
<span class="doccomment">/// must be white in order to preserve each pixel.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// In erode, for each pixel, the mask is centered at the pixel. If each pixel of the mask matches</span>
<span class="doccomment">/// the corresponding pixel on the image, then no change is made. If there is at least one</span>
<span class="doccomment">/// mismatch, then pixels are changed to the background color (black).</span>
<span class="doccomment">///</span>
<span class="doccomment">/// For further reference, see [here](https://en.wikipedia.org/wiki/Erosion_(morphology)).</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image</span>
<span class="doccomment">/// - `mask` is the morphological operation mask</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Eroded Image(Array)</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">erode</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">mask</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">ImageFilterType</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_erode</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>.<span class="ident">get</span>(), <span class="ident">mask</span>.<span class="ident">get</span>());
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Dilate a Volume</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Dilation for a volume is similar to the way dilation works on an image. Only difference is that</span>
<span class="doccomment">/// the masking operation is performed on a volume instead of a rectangular region.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input volume</span>
<span class="doccomment">/// - `mask` is the morphological operation mask</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Dilated Volume(Array)</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">dilate3</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">mask</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">ImageFilterType</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_dilate3</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>.<span class="ident">get</span>(), <span class="ident">mask</span>.<span class="ident">get</span>());
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Erode a Volume</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Erosion for a volume is similar to the way erosion works on an image. Only difference is that</span>
<span class="doccomment">/// the masking operation is performed on a volume instead of a rectangular region.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input volume</span>
<span class="doccomment">/// - `mask` is the morphological operation mask</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Eroded Volume(Array)</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">erode3</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">mask</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">ImageFilterType</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_erode3</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>.<span class="ident">get</span>(), <span class="ident">mask</span>.<span class="ident">get</span>());
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Bilateral Filter.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// A bilateral filter is a edge-preserving filter that reduces noise in an image. The intensity of</span>
<span class="doccomment">/// each pixel is replaced by a weighted average of the intensities of nearby pixels. The weights</span>
<span class="doccomment">/// follow a Gaussian distribution and depend on the distance as well as the color distance.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The bilateral filter requires the size of the filter (in pixels) and the upper bound on color</span>
<span class="doccomment">/// values, N, where pixel values range from 0–N inclusively.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` array is the input image</span>
<span class="doccomment">/// - `spatial_sigma` is the spatial variance parameter that decides the filter window</span>
<span class="doccomment">/// - `chromatic_sigma` is the chromatic variance parameter</span>
<span class="doccomment">/// - `iscolor` indicates if the input is color image or grayscale</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Filtered Image - Array</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bilateral</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">spatial_sigma</span>: <span class="ident">f32</span>,
    <span class="ident">chromatic_sigma</span>: <span class="ident">f32</span>,
    <span class="ident">iscolor</span>: <span class="ident">bool</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T::AbsOutType</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">ImageFilterType</span>,
    <span class="ident">T::AbsOutType</span>: <span class="ident">HasAfEnum</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_bilateral</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">spatial_sigma</span>,
            <span class="ident">chromatic_sigma</span>,
            <span class="ident">iscolor</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Meanshift Filter.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// A meanshift filter is an edge-preserving smoothing filter commonly used in object tracking and</span>
<span class="doccomment">/// image segmentation.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This filter replaces each pixel in the image with the mean of the values within a given given</span>
<span class="doccomment">/// color and spatial radius. The meanshift filter is an iterative algorithm that continues until a</span>
<span class="doccomment">/// maxium number of iterations is met or until the value of the means no longer changes.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` array is the input image</span>
<span class="doccomment">/// - `spatial_sigma` is the spatial variance parameter that decides the filter window</span>
<span class="doccomment">/// - `chromatic_sigma` is the chromatic variance parameter</span>
<span class="doccomment">/// - `iter` is the number of iterations filter operation is performed</span>
<span class="doccomment">/// - `iscolor` indicates if the input is color image or grayscale</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Filtered Image - Array</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mean_shift</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">spatial_sigma</span>: <span class="ident">f32</span>,
    <span class="ident">chromatic_sigma</span>: <span class="ident">f32</span>,
    <span class="ident">iter</span>: <span class="ident">u32</span>,
    <span class="ident">iscolor</span>: <span class="ident">bool</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">RealNumber</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_mean_shift</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">spatial_sigma</span>,
            <span class="ident">chromatic_sigma</span>,
            <span class="ident">iter</span>,
            <span class="ident">iscolor</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="macro">macro_rules!</span> <span class="ident">filt_func_def</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">doc_str</span>: <span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">fn_name</span>: <span class="ident">ident</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ffi_name</span>: <span class="ident">ident</span>) =&gt; {
        <span class="attribute">#[<span class="ident">doc</span><span class="op">=</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">doc_str</span>]</span>
        <span class="doccomment">///</span>
        <span class="doccomment">///# Parameters</span>
        <span class="doccomment">///</span>
        <span class="doccomment">/// - `input` is the input image(Array)</span>
        <span class="doccomment">/// - `wlen` is the horizontal length of the filter</span>
        <span class="doccomment">/// - `hlen` is the vertical length of the filter</span>
        <span class="doccomment">/// - `etype` is enum of type [BorderType](./enum.BorderType.html)</span>
        <span class="doccomment">///</span>
        <span class="doccomment">///# Return Values</span>
        <span class="doccomment">///</span>
        <span class="doccomment">/// An Array with filtered image data.</span>
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">fn_name</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">wlen</span>: <span class="ident">u64</span>, <span class="ident">wwid</span>: <span class="ident">u64</span>, <span class="ident">etype</span>: <span class="ident">BorderType</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
        <span class="kw">where</span>
            <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">ImageFilterType</span>,
        {
            <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
                <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ffi_name</span>(
                    <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
                    <span class="ident">input</span>.<span class="ident">get</span>(),
                    <span class="ident">wlen</span> <span class="kw">as</span> <span class="ident">dim_t</span>,
                    <span class="ident">wwid</span> <span class="kw">as</span> <span class="ident">dim_t</span>,
                    <span class="ident">etype</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
                );
                <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
                <span class="ident">temp</span>.<span class="ident">into</span>()
            }
        }
    };
}

<span class="macro">filt_func_def!</span>(<span class="string">&quot;Median filter&quot;</span>, <span class="ident">medfilt</span>, <span class="ident">af_medfilt</span>);
<span class="macro">filt_func_def!</span>(
    <span class="string">&quot;Box filter with minimum as box operation&quot;</span>,
    <span class="ident">minfilt</span>,
    <span class="ident">af_minfilt</span>
);
<span class="macro">filt_func_def!</span>(
    <span class="string">&quot;Box filter with maximum as box operation&quot;</span>,
    <span class="ident">maxfilt</span>,
    <span class="ident">af_maxfilt</span>
);

<span class="doccomment">/// Creates a Gaussian Kernel.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This function creates a kernel of a specified size that contains a Gaussian distribution. This</span>
<span class="doccomment">/// distribution is normalized to one. This is most commonly used when performing a Gaussian blur</span>
<span class="doccomment">/// on an image. The function takes two sets of arguments, the size of the kernel (width and height</span>
<span class="doccomment">/// in pixels) and the sigma parameters (for row and column) which effect the distribution of the</span>
<span class="doccomment">/// weights in the y and x directions, respectively.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Changing sigma causes the weights in each direction to vary. Sigma is calculated internally as</span>
<span class="doccomment">/// (0.25 * rows + 0.75) for rows and similarly for columns.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `rows` is number of rows of kernel</span>
<span class="doccomment">/// - `cols` is number of cols of kernel</span>
<span class="doccomment">/// - `sigma_r` is standard deviation of rows</span>
<span class="doccomment">/// - `sigma_c` is standard deviation of cols</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// An Array with gaussian kernel values</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">gaussian_kernel</span>(<span class="ident">rows</span>: <span class="ident">i32</span>, <span class="ident">cols</span>: <span class="ident">i32</span>, <span class="ident">sigma_r</span>: <span class="ident">f64</span>, <span class="ident">sigma_c</span>: <span class="ident">f64</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span> {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_gaussian_kernel</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">rows</span>, <span class="ident">cols</span>, <span class="ident">sigma_r</span>, <span class="ident">sigma_c</span>);
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Color space conversion</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Following are the supported conversions</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - RGB =&gt; GRAY</span>
<span class="doccomment">/// - GRAY =&gt; RGB</span>
<span class="doccomment">/// - RGB =&gt; HSV</span>
<span class="doccomment">/// - HSV =&gt; RGB</span>
<span class="doccomment">/// - YCbCr =&gt; RGB</span>
<span class="doccomment">/// - RGB =&gt; YCbCr</span>
<span class="doccomment">///</span>
<span class="doccomment">/// RGB (Red, Green, Blue) is the most common format used in computer imaging. RGB stores</span>
<span class="doccomment">/// individual values for red, green and blue, and hence the 3 values per pixel. A combination of</span>
<span class="doccomment">/// these three values produces the gamut of unique colors.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// HSV (Hue, Saturation, Value), also known as HSB (hue, saturation, brightness), is often used by</span>
<span class="doccomment">/// artists because it is more natural to think about a color in terms of hue and saturation than</span>
<span class="doccomment">/// in terms of additive or subtractive color components (as in RGB). HSV is a transformation of</span>
<span class="doccomment">/// RGB colorspace; its components and colorimetry are relative to the RGB colorspace from which it</span>
<span class="doccomment">/// was derived. Like RGB, HSV also uses 3 values per pixel.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// GRAY is a single channel color space where pixel value ranges from 0 to 1. Zero represents</span>
<span class="doccomment">/// black, one represent white and any value between zero &amp; one is a gray value</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image</span>
<span class="doccomment">/// - `tospace` is the target color space. Takes values of [ColorSpace](./enum.ColorSpace.html)</span>
<span class="doccomment">/// - `fromspace` is the source image color space. Takes values of</span>
<span class="doccomment">/// [ColorSpace](./enum.ColorSpace.html)</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// An Array with input image values in target color space</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">color_space</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">tospace</span>: <span class="ident">ColorSpace</span>, <span class="ident">fromspace</span>: <span class="ident">ColorSpace</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">RealNumber</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_color_space</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">tospace</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
            <span class="ident">fromspace</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Find blobs in given image.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Given a binary image (with zero representing background pixels), regions computes a floating</span>
<span class="doccomment">/// point image where each connected component is labeled from 1 to N, the total number of</span>
<span class="doccomment">/// components in the image.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// A component is defined as one or more nonzero pixels that are connected by the specified</span>
<span class="doccomment">/// connectivity (either [`Connectivity::FOUR`](./enum.Connectivity.html) or [`Connectivity::EIGHT`](./enum.Connectivity.html)) in two dimensions.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image</span>
<span class="doccomment">/// - `conn` can take one of the values of [Connectivity](./enum.Connectivity.html)</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Array with labels indicating different regions</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">regions</span><span class="op">&lt;</span><span class="ident">OutType</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>, <span class="ident">conn</span>: <span class="ident">Connectivity</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">OutType</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">OutType</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">RealNumber</span>,
{
    <span class="kw">let</span> <span class="ident">otype</span> <span class="op">=</span> <span class="ident">OutType::get_af_dtype</span>();
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_regions</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">conn</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
            <span class="ident">otype</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Sobel Operator</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Sobel operators perform a 2-D spatial gradient measurement on an image to emphasize the regions</span>
<span class="doccomment">/// of high spatial frequency, namely edges. A more in depth discussion on it can be found [here](https://en.wikipedia.org/wiki/Sobel_operator).</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image</span>
<span class="doccomment">/// - `ker_size` is the kernel size of sobel operator</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// A tuple of Arrays.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The first Array has derivatives along horizontal direction</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The second Array has derivatives along vertical direction</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">sobel</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">ker_size</span>: <span class="ident">u32</span>) -&gt; (<span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T::SobelOutType</span><span class="op">&gt;</span>, <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T::SobelOutType</span><span class="op">&gt;</span>)
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">ImageFilterType</span>,
    <span class="ident">T::SobelOutType</span>: <span class="ident">HasAfEnum</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dx</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dy</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_sobel_operator</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">dx</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="kw-2">&amp;mut</span> <span class="ident">dy</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">ker_size</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        (<span class="ident">dx</span>.<span class="ident">into</span>(), <span class="ident">dy</span>.<span class="ident">into</span>())
    }
}

<span class="doccomment">/// Histogram Equalization</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input Array to be equalized</span>
<span class="doccomment">/// - `hist` is the Array to be used for equalizing input</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">/// Equalized Array</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hist_equal</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">hist</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">RealNumber</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_hist_equal</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>.<span class="ident">get</span>(), <span class="ident">hist</span>.<span class="ident">get</span>());
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="macro">macro_rules!</span> <span class="ident">grayrgb_func_def</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">doc_str</span>: <span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">fn_name</span>: <span class="ident">ident</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ffi_name</span>: <span class="ident">ident</span>) =&gt; {
        <span class="attribute">#[<span class="ident">doc</span><span class="op">=</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">doc_str</span>]</span>
        <span class="doccomment">///</span>
        <span class="doccomment">///# Parameters</span>
        <span class="doccomment">///</span>
        <span class="doccomment">/// - `r` is fraction of red channel to appear in output</span>
        <span class="doccomment">/// - `g` is fraction of green channel to appear in output</span>
        <span class="doccomment">/// - `b` is fraction of blue channel to appear in output</span>
        <span class="doccomment">///</span>
        <span class="doccomment">///#Return Values</span>
        <span class="doccomment">///</span>
        <span class="doccomment">///An Array with image data in target color space</span>
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">fn_name</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">r</span>: <span class="ident">f32</span>, <span class="ident">g</span>: <span class="ident">f32</span>, <span class="ident">b</span>: <span class="ident">f32</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
        <span class="kw">where</span>
            <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">GrayRGBConvertible</span>,
        {
            <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
                <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ffi_name</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>.<span class="ident">get</span>(), <span class="ident">r</span>, <span class="ident">g</span>, <span class="ident">b</span>);
                <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
                <span class="ident">temp</span>.<span class="ident">into</span>()
            }
        }
    };
}

<span class="macro">grayrgb_func_def!</span>(<span class="string">&quot;Color(RGB) to Grayscale conversion&quot;</span>, <span class="ident">rgb2gray</span>, <span class="ident">af_rgb2gray</span>);
<span class="macro">grayrgb_func_def!</span>(<span class="string">&quot;Grayscale to Color(RGB) conversion&quot;</span>, <span class="ident">gray2rgb</span>, <span class="ident">af_gray2rgb</span>);

<span class="macro">macro_rules!</span> <span class="ident">hsvrgb_func_def</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">doc_str</span>: <span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">fn_name</span>: <span class="ident">ident</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ffi_name</span>: <span class="ident">ident</span>) =&gt; {
        <span class="attribute">#[<span class="ident">doc</span><span class="op">=</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">doc_str</span>]</span>
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">fn_name</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
        <span class="kw">where</span>
            <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">RealFloating</span>,
        {
            <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
                <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">ffi_name</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>.<span class="ident">get</span>());
                <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
                <span class="ident">temp</span>.<span class="ident">into</span>()
            }
        }
    };
}

<span class="macro">hsvrgb_func_def!</span>(<span class="string">&quot;HSV to RGB color space conversion&quot;</span>, <span class="ident">hsv2rgb</span>, <span class="ident">af_hsv2rgb</span>);
<span class="macro">hsvrgb_func_def!</span>(<span class="string">&quot;RGB to HSV color space conversion&quot;</span>, <span class="ident">rgb2hsv</span>, <span class="ident">af_rgb2hsv</span>);

<span class="doccomment">/// Generate an array with image windows as columns</span>
<span class="doccomment">///</span>
<span class="doccomment">/// unwrap takes in an input image along with the window sizes wx and wy, strides sx and sy, and</span>
<span class="doccomment">/// padding px and py. This function then generates a matrix where each windows is an independent</span>
<span class="doccomment">/// column.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The number of columns (rows if is_column is true) in the output array are govenered by the</span>
<span class="doccomment">/// number of windows that can be fit along x and y directions. Padding is applied along all 4</span>
<span class="doccomment">/// sides of the matrix with px defining the height of the padding along dim 0 and py defining the</span>
<span class="doccomment">/// width of the padding along dim 1.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The first column window is always at the top left corner of the input including padding. If a</span>
<span class="doccomment">/// window cannot fit before the end of the matrix + padding, it is skipped from the generated</span>
<span class="doccomment">/// matrix.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Padding can take a maximum value of window - 1 repectively for x and y.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// For multiple channels (3rd and 4th dimension), the generated matrix contains the same number of</span>
<span class="doccomment">/// channels as the input matrix. Each channel of the output matrix corresponds to the same channel</span>
<span class="doccomment">/// of the input.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image</span>
<span class="doccomment">/// - `wx` is the block window size along 0th-dimension between \[1, input.dims\[0\] + px\]</span>
<span class="doccomment">/// - `wy` is the block window size along 1st-dimension between \[1, input.dims\[1\] + py\]</span>
<span class="doccomment">/// - `sx` is the stride along 0th-dimension</span>
<span class="doccomment">/// - `sy` is the stride along 1st-dimension</span>
<span class="doccomment">/// - `px` is the padding along 0th-dimension between [0, wx). Padding is applied both before and after.</span>
<span class="doccomment">/// - `py` is the padding along 1st-dimension between [0, wy). Padding is applied both before and after.</span>
<span class="doccomment">/// - `is_column` specifies the layout for the unwrapped patch. If is_column is false, the unrapped patch is laid out as a row.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// An Array with image windows as columns</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Examples</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```text</span>
<span class="doccomment">/// A [5 5 1 1]</span>
<span class="doccomment">/// 10 15 20 25 30</span>
<span class="doccomment">/// 11 16 21 26 31</span>
<span class="doccomment">/// 12 17 22 27 32</span>
<span class="doccomment">/// 13 18 23 28 33</span>
<span class="doccomment">/// 14 19 24 29 34</span>
<span class="doccomment">///</span>
<span class="doccomment">/// // Window 3x3, strides 1x1, padding 0x0</span>
<span class="doccomment">/// unwrap(A, 3, 3, 1, 1, 0, 0, False) [9 9 1 1]</span>
<span class="doccomment">/// 10 11 12 15 16 17 20 21 22</span>
<span class="doccomment">/// 11 12 13 16 17 18 21 22 23</span>
<span class="doccomment">/// 12 13 14 17 18 19 22 23 24</span>
<span class="doccomment">/// 15 16 17 20 21 22 25 26 27</span>
<span class="doccomment">/// 16 17 18 21 22 23 26 27 28</span>
<span class="doccomment">/// 17 18 19 22 23 24 27 28 29</span>
<span class="doccomment">/// 20 21 22 25 26 27 30 31 32</span>
<span class="doccomment">/// 21 22 23 26 27 28 31 32 33</span>
<span class="doccomment">/// 22 23 24 27 28 29 32 33 34</span>
<span class="doccomment">///</span>
<span class="doccomment">/// // Window 3x3, strides 1x1, padding 1x1</span>
<span class="doccomment">/// unwrap(A, 3, 3, 1, 1, 1, 1, False) [9 25 1 1]</span>
<span class="doccomment">///  0  0  0  0  0  0 10 11 12 13  0 15 16 17 18  0 20 21 22 23  0 25 26 27 28</span>
<span class="doccomment">///  0  0  0  0  0 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29</span>
<span class="doccomment">///  0  0  0  0  0 11 12 13 14  0 16 17 18 19  0 21 22 23 24  0 26 27 28 29  0</span>
<span class="doccomment">///  0 10 11 12 13  0 15 16 17 18  0 20 21 22 23  0 25 26 27 28  0 30 31 32 33</span>
<span class="doccomment">/// 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34</span>
<span class="doccomment">/// 11 12 13 14  0 16 17 18 19  0 21 22 23 24  0 26 27 28 29  0 31 32 33 34  0</span>
<span class="doccomment">///  0 15 16 17 18  0 20 21 22 23  0 25 26 27 28  0 30 31 32 33  0  0  0  0  0</span>
<span class="doccomment">/// 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  0  0  0  0  0</span>
<span class="doccomment">/// 16 17 18 19  0 21 22 23 24  0 26 27 28 29  0 31 32 33 34  0  0  0  0  0  0</span>
<span class="doccomment">/// ```</span>
<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::too_many_arguments</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">unwrap</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">HasAfEnum</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">wx</span>: <span class="ident">i64</span>,
    <span class="ident">wy</span>: <span class="ident">i64</span>,
    <span class="ident">sx</span>: <span class="ident">i64</span>,
    <span class="ident">sy</span>: <span class="ident">i64</span>,
    <span class="ident">px</span>: <span class="ident">i64</span>,
    <span class="ident">py</span>: <span class="ident">i64</span>,
    <span class="ident">is_column</span>: <span class="ident">bool</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_unwrap</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">wx</span>,
            <span class="ident">wy</span>,
            <span class="ident">sx</span>,
            <span class="ident">sy</span>,
            <span class="ident">px</span>,
            <span class="ident">py</span>,
            <span class="ident">is_column</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Converts unwrapped image to an image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Wrap takes an unwrapped image (see unwrap()) and converts it back to an image.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The inputs to this function should be the same as the inputs used to generate the unwrapped</span>
<span class="doccomment">/// image.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the output of unwrap function call</span>
<span class="doccomment">/// - `ox` is the 0th-dimension of output image</span>
<span class="doccomment">/// - `oy` is the 1st-dimension of output image</span>
<span class="doccomment">/// - `wx` is the block window size along 0th-dimension between</span>
<span class="doccomment">/// - `wy` is the block window size along 1st-dimension between</span>
<span class="doccomment">/// - `sx` is the stride along 0th-dimension</span>
<span class="doccomment">/// - `sy` is the stride along 1st-dimension</span>
<span class="doccomment">/// - `px` is the padding used along 0th-dimension between [0, wx).</span>
<span class="doccomment">/// - `py` is the padding used along 1st-dimension between [0, wy).</span>
<span class="doccomment">/// - `is_column` specifies the layout for the unwrapped patch. If is_column is false, the rows are treated as the patches</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Image(Array) created from unwrapped Image(Array)</span>
<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::too_many_arguments</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">wrap</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">HasAfEnum</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">ox</span>: <span class="ident">i64</span>,
    <span class="ident">oy</span>: <span class="ident">i64</span>,
    <span class="ident">wx</span>: <span class="ident">i64</span>,
    <span class="ident">wy</span>: <span class="ident">i64</span>,
    <span class="ident">sx</span>: <span class="ident">i64</span>,
    <span class="ident">sy</span>: <span class="ident">i64</span>,
    <span class="ident">px</span>: <span class="ident">i64</span>,
    <span class="ident">py</span>: <span class="ident">i64</span>,
    <span class="ident">is_column</span>: <span class="ident">bool</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_wrap</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">ox</span>,
            <span class="ident">oy</span>,
            <span class="ident">wx</span>,
            <span class="ident">wy</span>,
            <span class="ident">sx</span>,
            <span class="ident">sy</span>,
            <span class="ident">px</span>,
            <span class="ident">py</span>,
            <span class="ident">is_column</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Summed area table of an Image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Summed area table (a.k.a Integral Image) of the input image.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">sat</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T::AggregateOutType</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">RealNumber</span>,
    <span class="ident">T::AggregateOutType</span>: <span class="ident">HasAfEnum</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_sat</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>.<span class="ident">get</span>());
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// RGB to YCbCr colorspace converter.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// RGB (Red, Green, Blue) is the most common format used in computer imaging. RGB stores</span>
<span class="doccomment">/// individual values for red, green and blue, and hence the 3 values per pixel. A combination of</span>
<span class="doccomment">/// these three values produces the gamut of unique colors.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// YCbCr is a family of color spaces used as a part of the color image pipeline in video and</span>
<span class="doccomment">/// digital photography systems where Y is luma component and Cb &amp; Cr are the blue-difference and</span>
<span class="doccomment">/// red-difference chroma components.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Input array to this function should be of real data in the range [0,1].</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image in RGB color space</span>
<span class="doccomment">/// - `standard` is the target color space - [YCbCr standard](./enum.YCCStd.html)</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Image(Array) in YCbCr color space</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">rgb2ycbcr</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">standard</span>: <span class="ident">YCCStd</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">RealFloating</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_rgb2ycbcr</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>.<span class="ident">get</span>(), <span class="ident">standard</span> <span class="kw">as</span> <span class="ident">c_uint</span>);
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// YCbCr to RGB colorspace converter.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// YCbCr is a family of color spaces used as a part of the color image pipeline in video and</span>
<span class="doccomment">/// digital photography systems where Y is luma component and Cb &amp; Cr are the blue-difference and</span>
<span class="doccomment">/// red-difference chroma components.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// RGB (Red, Green, Blue) is the most common format used in computer imaging. RGB stores</span>
<span class="doccomment">/// individual values for red, green and blue, and hence the 3 values per pixel. A combination of</span>
<span class="doccomment">/// these three values produces the gamut of unique colors.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Input array to this function should be of real data with the following range in their</span>
<span class="doccomment">/// respective channels.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - Y  −&gt; [16,219]</span>
<span class="doccomment">/// - Cb −&gt; [16,240]</span>
<span class="doccomment">/// - Cr −&gt; [16,240]</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image in YCbCr color space</span>
<span class="doccomment">/// - `standard` is the [YCbCr standard](./enum.YCCStd.html) in which input image color space is</span>
<span class="doccomment">/// present.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Image(Array) in RGB color space</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">ycbcr2rgb</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">standard</span>: <span class="ident">YCCStd</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">RealFloating</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_ycbcr2rgb</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>.<span class="ident">get</span>(), <span class="ident">standard</span> <span class="kw">as</span> <span class="ident">c_uint</span>);
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Function to check if Image I/O is available</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// None</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Return a boolean indicating if ArrayFire was compiled with Image I/O support</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">is_imageio_available</span>() -&gt; <span class="ident">bool</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">bool</span> <span class="op">=</span> <span class="bool-val">false</span>;
    <span class="kw">unsafe</span> {
        <span class="ident">af_is_image_io_available</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">bool</span>);
    }
    <span class="ident">temp</span>
}

<span class="doccomment">/// Transform input coordinates</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The transform function uses a perspective transform matrix to transform input coordinates</span>
<span class="doccomment">/// (given as two dimensions) into a coordinates matrix.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The output is a 4x2 matrix, indicating the coordinates of the 4 bidimensional transformed</span>
<span class="doccomment">/// points.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `tf` is the transformation matrix</span>
<span class="doccomment">/// - `d0` is the first input dimension</span>
<span class="doccomment">/// - `d1` is the second input dimension</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Transformed coordinates</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">transform_coords</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">tf</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">d0</span>: <span class="ident">f32</span>, <span class="ident">d1</span>: <span class="ident">f32</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">RealFloating</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_transform_coordinates</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">tf</span>.<span class="ident">get</span>(), <span class="ident">d0</span>, <span class="ident">d1</span>);
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Find Image moments</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image</span>
<span class="doccomment">/// - `moment` is the type of moment to be computed, takes a value of</span>
<span class="doccomment">/// [enum](./enum.MomentType.html)</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Moments Array</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">moments</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">moment</span>: <span class="ident">MomentType</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">MomentsComputable</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_moments</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>, <span class="ident">input</span>.<span class="ident">get</span>(), <span class="ident">moment</span> <span class="kw">as</span> <span class="ident">c_uint</span>);
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Find Image moment for whole image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image</span>
<span class="doccomment">/// - `moment` is the type of moment to be computed, takes a value of</span>
<span class="doccomment">/// [enum](./enum.MomentType.html)</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Moment value of the whole image</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">moments_all</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">moment</span>: <span class="ident">MomentType</span>) -&gt; <span class="ident">f64</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">MomentsComputable</span>,
{
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">f64</span> <span class="op">=</span> <span class="number">0.0</span>;
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_moments_all</span>(<span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">c_double</span>, <span class="ident">input</span>.<span class="ident">get</span>(), <span class="ident">moment</span> <span class="kw">as</span> <span class="ident">c_uint</span>);
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
    }
    <span class="ident">temp</span>
}

<span class="doccomment">/// One dimensional median filter on image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">///  - `input` is the input image(Array)</span>
<span class="doccomment">///  - `wlen` is the horizontal length of the filter</span>
<span class="doccomment">///  - `etype` is enum of type [BorderType](./enum.BorderType.html)</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// An Array with filtered image data.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">medfilt1</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">wlen</span>: <span class="ident">u64</span>, <span class="ident">etype</span>: <span class="ident">BorderType</span>) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">ImageFilterType</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_medfilt1</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">wlen</span> <span class="kw">as</span> <span class="ident">dim_t</span>,
            <span class="ident">etype</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Canny edge detection operator</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The Canny edge detector is an edge detection operator that uses a multi-stage algorithm to detect a wide range of edges in images. A more in depth discussion on it can be found [here](https://en.wikipedia.org/wiki/Canny_edge_detector).</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image</span>
<span class="doccomment">/// - `threshold_type` helps determine if user set high threshold is to be used or not. It can take values defined by the enum [CannyThresholdType](./enum.CannyThresholdType.html)</span>
<span class="doccomment">/// - `low` is the lower threshold % of the maximum or auto-derived high</span>
<span class="doccomment">/// - `high` is the higher threshold % of maximum value in gradient image used in hysteresis procedure. This value is ignored if [CannyThresholdType::OTSU](./enum.CannyThresholdType.html) is chosen.</span>
<span class="doccomment">/// - `sobel_window` is the window size of sobel kernel for computing gradient direction and magnitude.</span>
<span class="doccomment">/// - `is_fast` indicates if L&lt;SUB&gt;1&lt;/SUB&gt; norm(faster but less accurate) is used to compute image gradient magnitude instead of L&lt;SUB&gt;2&lt;/SUB&gt; norm.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// An Array of binary type [DType::B8](./enum.DType.html) indicating edges(All pixels with</span>
<span class="doccomment">/// non-zero values are edges).</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">canny</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">threshold_type</span>: <span class="ident">CannyThresholdType</span>,
    <span class="ident">low</span>: <span class="ident">f32</span>,
    <span class="ident">high</span>: <span class="ident">f32</span>,
    <span class="ident">sobel_window</span>: <span class="ident">u32</span>,
    <span class="ident">is_fast</span>: <span class="ident">bool</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">EdgeComputable</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_canny</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">threshold_type</span> <span class="kw">as</span> <span class="ident">c_int</span>,
            <span class="ident">low</span>,
            <span class="ident">high</span>,
            <span class="ident">sobel_window</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
            <span class="ident">is_fast</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Anisotropic smoothing filter</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Anisotropic diffusion algorithm aims at removing noise in the images</span>
<span class="doccomment">/// while preserving important features such as edges. The algorithm</span>
<span class="doccomment">/// essentially creates a scale space representation of the original</span>
<span class="doccomment">/// image, where image from previous step is used to create a new version</span>
<span class="doccomment">/// of blurred image using the diffusion process. Standard isotropic diffusion</span>
<span class="doccomment">/// methods such as gaussian blur, doesn&#39;t take into account the local</span>
<span class="doccomment">/// content(smaller neighborhood of current processing pixel) while removing</span>
<span class="doccomment">/// noise. Anisotropic diffusion uses the flux equations given below to</span>
<span class="doccomment">/// achieve that. Flux equation is the formula used by the diffusion process</span>
<span class="doccomment">/// to determine how much a pixel in neighborhood should contribute to</span>
<span class="doccomment">/// the blurring operation being done at the current pixel at a given iteration.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The flux function can be either exponential or quadratic.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// &lt;table&gt;</span>
<span class="doccomment">/// &lt;caption id=&quot;multi row&quot;&gt;Available Flux Functions&lt;/caption&gt;</span>
<span class="doccomment">/// &lt;tr&gt;</span>
<span class="doccomment">///     &lt;td align=&quot;center&quot; style=&quot;vertical-align:middle;&quot;&gt;</span>
<span class="doccomment">///       AF_FLUX_QUADRATIC</span>
<span class="doccomment">///     &lt;/td&gt;</span>
<span class="doccomment">///     &lt;td align=&quot;center&quot;&gt;</span>
<span class="doccomment">///       \begin{equation}</span>
<span class="doccomment">///         \frac{1}{1 + (\frac{\| \nabla I\|}{K})^2}</span>
<span class="doccomment">///       \end{equation}</span>
<span class="doccomment">///     &lt;/td&gt;</span>
<span class="doccomment">/// &lt;/tr&gt;</span>
<span class="doccomment">/// &lt;tr&gt;</span>
<span class="doccomment">///     &lt;td align=&quot;center&quot; style=&quot;vertical-align:middle;&quot;&gt;</span>
<span class="doccomment">///       AF_FLUX_EXPONENTIAL</span>
<span class="doccomment">///     &lt;/td&gt;</span>
<span class="doccomment">///     &lt;td align=&quot;center&quot;&gt;</span>
<span class="doccomment">///       \begin{equation}</span>
<span class="doccomment">///         \exp{-(\frac{\| \nabla I\|}{K})^2}</span>
<span class="doccomment">///       \end{equation}</span>
<span class="doccomment">///     &lt;/td&gt;</span>
<span class="doccomment">/// &lt;/tr&gt;</span>
<span class="doccomment">/// &lt;/table&gt;</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Please be cautious using the time step parameter to the function.</span>
<span class="doccomment">/// Appropriate time steps for solving this type of p.d.e. depend on</span>
<span class="doccomment">/// the dimensionality of the image and the order of the equation.</span>
<span class="doccomment">/// Stable values for most 2D and 3D functions are 0.125 and 0.0625,</span>
<span class="doccomment">/// respectively. The time step values are automatically constrained</span>
<span class="doccomment">/// to the stable value.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Another input parameter to be cautious about is the conductance</span>
<span class="doccomment">/// parameter, lower values strongly preserve image features and</span>
<span class="doccomment">/// vice-versa. For human vision, this value ranges from 0.5 to 2.0.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `img` is the noisy input image</span>
<span class="doccomment">/// - `dt` is the timestep for diffusion equation</span>
<span class="doccomment">/// - `k` is the conductance parameter for diffusion</span>
<span class="doccomment">/// - `iters` is the number of iterations diffusion is performed</span>
<span class="doccomment">/// - `fftype` dictates the type of flux flow and it is an</span>
<span class="doccomment">///    [enum](./enum.DiffusionEq.html)</span>
<span class="doccomment">/// - `diff_kind` dictates the type of diffusion and it is an</span>
<span class="doccomment">///   [enum](./enum.FluxFn.html)</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Returns an anisotropically smoothed and noise-free image</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ### References</span>
<span class="doccomment">///</span>
<span class="doccomment">///  - Pietro Perona and Jitendra Malik, `Scale-space and edge detection</span>
<span class="doccomment">///    using anisotropic diffusion,` IEEE Transactions on Pattern Analysis</span>
<span class="doccomment">///    Machine Intelligence, vol. 12, pp. 629-639, 1990.</span>
<span class="doccomment">///  - R. Whitaker and X. Xue. `Variable-Conductance, Level-Set Curvature</span>
<span class="doccomment">///    for Image Denoising`, International Conference on Image Processing,</span>
<span class="doccomment">///    2001 pp. 142-145, Vol.3.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">anisotropic_diffusion</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(
    <span class="ident">img</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">dt</span>: <span class="ident">f32</span>,
    <span class="ident">k</span>: <span class="ident">f32</span>,
    <span class="ident">iters</span>: <span class="ident">u32</span>,
    <span class="ident">fftype</span>: <span class="ident">FluxFn</span>,
    <span class="ident">diff_kind</span>: <span class="ident">DiffusionEq</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T::AbsOutType</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">HasAfEnum</span> <span class="op">+</span> <span class="ident">EdgeComputable</span>,
    <span class="ident">T::AbsOutType</span>: <span class="ident">HasAfEnum</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_anisotropic_diffusion</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">img</span>.<span class="ident">get</span>(),
            <span class="ident">dt</span>,
            <span class="ident">k</span>,
            <span class="ident">iters</span>,
            <span class="ident">fftype</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
            <span class="ident">diff_kind</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Segment image based on similar pixel characteristics</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This filter is similar to [regions](./fn.regions.html) with additional criteria for</span>
<span class="doccomment">/// segmentation. In regions, all connected pixels are considered to be a single component.</span>
<span class="doccomment">/// In this variation of connected components, pixels having similar pixel statistics of the</span>
<span class="doccomment">/// neighborhoods around a given set of seed points are grouped together.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The parameter `radius` determines the size of neighborhood around a seed point.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Mean and Variance are the pixel statistics that are computed across all neighborhoods around</span>
<span class="doccomment">/// the given set of seed points. The pixels which are connected to seed points and lie in the</span>
<span class="doccomment">/// confidence interval are grouped together. Given below is the confidence interval.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// \begin{equation}</span>
<span class="doccomment">///     [\mu - \alpha * \sigma, \mu + \alpha * \sigma]</span>
<span class="doccomment">/// \end{equation}</span>
<span class="doccomment">/// where</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - $ \mu $ is the mean of the pixels in the seed neighborhood</span>
<span class="doccomment">/// - $ \sigma^2 $ is the variance of the pixels in the seed neighborhood</span>
<span class="doccomment">/// - $ \alpha $ is the multiplier used to control the width of the confidence interval.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This filter follows an iterative approach for fine tuning the segmentation. An initial</span>
<span class="doccomment">/// segmenetation followed by a finite number `iterations` of segmentations are performed.</span>
<span class="doccomment">/// The user provided parameter `iterations` is only a request and the algorithm can prempt</span>
<span class="doccomment">/// the execution if variance approaches zero. The initial segmentation uses the mean and</span>
<span class="doccomment">/// variance calculated from the neighborhoods of all the seed points. For subsequent</span>
<span class="doccomment">/// segmentations, all pixels in the previous segmentation are used to re-calculate the mean</span>
<span class="doccomment">/// and variance (as opposed to using the pixels in the neighborhood of the seed point).</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Parameters</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `input` is the input image</span>
<span class="doccomment">/// - `seedx` contains the x coordinates of seeds in image coordinates</span>
<span class="doccomment">/// - `seedy` contains the y coordinates of seeds in image coordinates</span>
<span class="doccomment">/// - `radius` is the neighborhood region to be considered around each seed point</span>
<span class="doccomment">/// - `multiplier` controls the threshold range computed from the mean and variance of seed point neighborhoods</span>
<span class="doccomment">/// - `iterations` is the number of times the segmentation in performed</span>
<span class="doccomment">/// - `segmented_value` is the value to which output array valid pixels are set to</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return Values</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Segmented(based on pixel characteristics) image(Array) with regions surrounding the seed points</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">confidence_cc</span><span class="op">&lt;</span><span class="ident">InOutType</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">InOutType</span><span class="op">&gt;</span>,
    <span class="ident">seedx</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>,
    <span class="ident">seedy</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>,
    <span class="ident">radius</span>: <span class="ident">u32</span>,
    <span class="ident">multiplier</span>: <span class="ident">u32</span>,
    <span class="ident">iterations</span>: <span class="ident">u32</span>,
    <span class="ident">segmented_val</span>: <span class="ident">f64</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">InOutType</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">InOutType</span>: <span class="ident">ConfidenceCCInput</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_confidence_cc</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">seedx</span>.<span class="ident">get</span>(),
            <span class="ident">seedy</span>.<span class="ident">get</span>(),
            <span class="ident">radius</span>,
            <span class="ident">multiplier</span>,
            <span class="ident">iterations</span> <span class="kw">as</span> <span class="ident">i32</span>,
            <span class="ident">segmented_val</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Iterative Deconvolution</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The following table shows the iteration update equations of the respective</span>
<span class="doccomment">/// deconvolution algorithms.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// &lt;table&gt;</span>
<span class="doccomment">/// &lt;tr&gt;&lt;th&gt;Algorithm&lt;/th&gt;&lt;th&gt;Update Equation&lt;/th&gt;&lt;/tr&gt;</span>
<span class="doccomment">/// &lt;tr&gt;</span>
<span class="doccomment">///     &lt;td&gt;LandWeber&lt;/td&gt;</span>
<span class="doccomment">///     &lt;td&gt;</span>
<span class="doccomment">///         $ \hat{I}_{n} = \hat{I}_{n-1} + \alpha * P^T \otimes (I - P \otimes \hat{I}_{n-1}) $</span>
<span class="doccomment">///     &lt;/td&gt;</span>
<span class="doccomment">/// &lt;/tr&gt;</span>
<span class="doccomment">/// &lt;tr&gt;</span>
<span class="doccomment">///   &lt;td&gt;Richardson-Lucy&lt;/td&gt;</span>
<span class="doccomment">///   &lt;td&gt;</span>
<span class="doccomment">///     $ \hat{I}_{n} = \hat{I}_{n-1} . ( \frac{I}{\hat{I}_{n-1} \otimes P} \otimes P^T ) $</span>
<span class="doccomment">///   &lt;/td&gt;</span>
<span class="doccomment">/// &lt;/tr&gt;</span>
<span class="doccomment">/// &lt;/table&gt;</span>
<span class="doccomment">///</span>
<span class="doccomment">/// where</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - $ I $ is the observed(input/blurred) image</span>
<span class="doccomment">/// - $ P $ is the point spread function</span>
<span class="doccomment">/// - $ P^T $ is the transpose of point spread function</span>
<span class="doccomment">/// - $ \hat{I}_{n} $ is the current iteration&#39;s updated image estimate</span>
<span class="doccomment">/// - $ \hat{I}_{n-1} $ is the previous iteration&#39;s image estimate</span>
<span class="doccomment">/// - $ \alpha $ is the relaxation factor</span>
<span class="doccomment">/// - $ \otimes $ indicates the convolution operator</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The type of output Array from deconvolution will be of type f64 if</span>
<span class="doccomment">/// the input array type is f64. For other types, output type will be f32 type.</span>
<span class="doccomment">/// Should the caller want to save the image to disk or require the values of output</span>
<span class="doccomment">/// to be in a fixed range, that should be done by the caller explicitly.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">iterative_deconv</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">kernel</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span>,
    <span class="ident">iterations</span>: <span class="ident">u32</span>,
    <span class="ident">relaxation_factor</span>: <span class="ident">f32</span>,
    <span class="ident">algo</span>: <span class="ident">IterativeDeconvAlgo</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T::AbsOutType</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">DeconvInput</span>,
    <span class="ident">T::AbsOutType</span>: <span class="ident">HasAfEnum</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_iterative_deconv</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">kernel</span>.<span class="ident">get</span>(),
            <span class="ident">iterations</span>,
            <span class="ident">relaxation_factor</span>,
            <span class="ident">algo</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}

<span class="doccomment">/// Inverse deconvolution</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This is a linear algorithm i.e. they are non-iterative in</span>
<span class="doccomment">/// nature and usually faster than iterative deconvolution algorithms.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Depending on the values passed on to `algo` of type enum [InverseDeconvAlgo](./enum.inverse_deconv_algo.html),</span>
<span class="doccomment">/// different equations are used to compute the final result.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// #### Tikhonov&#39;s Deconvolution Method:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The update equation for this algorithm is as follows:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// &lt;div&gt;</span>
<span class="doccomment">/// \begin{equation}</span>
<span class="doccomment">/// \hat{I}_{\omega} = \frac{ I_{\omega} * P^{*}_{\omega} } { |P_{\omega}|^2 + \gamma }</span>
<span class="doccomment">/// \end{equation}</span>
<span class="doccomment">/// &lt;/div&gt;</span>
<span class="doccomment">///</span>
<span class="doccomment">/// where</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - $ I_{\omega} $ is the observed(input/blurred) image in frequency domain</span>
<span class="doccomment">/// - $ P_{\omega} $ is the point spread function in frequency domain</span>
<span class="doccomment">/// - $ \gamma $ is a user defined regularization constant</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The type of output Array from deconvolution will be double if the input array type is double.</span>
<span class="doccomment">/// Otherwise, it will be float in rest of the cases. Should the caller want to save the image to</span>
<span class="doccomment">/// disk or require the values of output to be in a fixed range, that should be done by the caller</span>
<span class="doccomment">/// explicitly.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">inverse_deconv</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(
    <span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">kernel</span>: <span class="kw-2">&amp;</span><span class="ident">Array</span><span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span>,
    <span class="ident">gamma</span>: <span class="ident">f32</span>,
    <span class="ident">algo</span>: <span class="ident">InverseDeconvAlgo</span>,
) -&gt; <span class="ident">Array</span><span class="op">&lt;</span><span class="ident">T::AbsOutType</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">DeconvInput</span>,
    <span class="ident">T::AbsOutType</span>: <span class="ident">HasAfEnum</span>,
{
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span>: <span class="ident">af_array</span> <span class="op">=</span> <span class="ident">std::ptr::null_mut</span>();
        <span class="kw">let</span> <span class="ident">err_val</span> <span class="op">=</span> <span class="ident">af_inverse_deconv</span>(
            <span class="kw-2">&amp;mut</span> <span class="ident">temp</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">af_array</span>,
            <span class="ident">input</span>.<span class="ident">get</span>(),
            <span class="ident">kernel</span>.<span class="ident">get</span>(),
            <span class="ident">gamma</span>,
            <span class="ident">algo</span> <span class="kw">as</span> <span class="ident">c_uint</span>,
        );
        <span class="ident">HANDLE_ERROR</span>(<span class="ident">AfError::from</span>(<span class="ident">err_val</span>));
        <span class="ident">temp</span>.<span class="ident">into</span>()
    }
}
</code></pre></div>
</section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="arrayfire" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.59.0 (9d1b2106e 2022-02-23)" ></div>
</body></html>